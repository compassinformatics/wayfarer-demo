{"version":3,"file":"Tile-331d8e26.js","sources":["../../node_modules/ol/Tile.js","../../node_modules/ol/ImageTile.js","../../node_modules/ol/TileRange.js","../../node_modules/ol/layer/TileProperty.js","../../node_modules/ol/layer/BaseTile.js","../../node_modules/ol/reproj/common.js","../../node_modules/ol/reproj/Triangulation.js","../../node_modules/ol/reproj.js","../../node_modules/ol/reproj/Tile.js","../../node_modules/ol/renderer/canvas/TileLayer.js","../../node_modules/ol/layer/Tile.js"],"sourcesContent":["/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport {abstract} from './util.js';\nimport {easeIn} from './easing.js';\n\n/**\n * A function that takes an {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * An \"interim\" tile for this tile. The interim tile may be used while this\n     * one is loading, for \"smooth\" transitions when changing params/dimensions\n     * on the source.\n     * @type {Tile}\n     */\n    this.interimTile = null;\n\n    /**\n     * A key assigned to the tile. This is used by the tile source to determine\n     * if this tile can effectively be used, or if a new tile should be created\n     * and this one be used as an interim tile for this new tile.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    if (this.state === TileState.ERROR) {\n      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n      this.setState(TileState.EMPTY);\n    }\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the interim tile most suitable for rendering using the chain of interim\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\n   * such tile exists, the original tile is returned.\n   * @return {!Tile} Best tile for rendering.\n   */\n  getInterimTile() {\n    if (!this.interimTile) {\n      //empty chain\n      return this;\n    }\n    let tile = this.interimTile;\n\n    // find the first loaded tile and return it. Since the chain is sorted in\n    // decreasing order of creation time, there is no need to search the remainder\n    // of the list (all those tiles correspond to older requests and will be\n    // cleaned up by refreshInterimChain)\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        // Show tile immediately instead of fading it in after loading, because\n        // the interim tile is in place already\n        this.transition_ = 0;\n        return tile;\n      }\n      tile = tile.interimTile;\n    } while (tile);\n\n    // we can not find a better tile\n    return this;\n  }\n\n  /**\n   * Goes through the chain of interim tiles and discards sections of the chain\n   * that are no longer relevant.\n   */\n  refreshInterimChain() {\n    if (!this.interimTile) {\n      return;\n    }\n\n    let tile = this.interimTile;\n\n    /**\n     * @type {Tile}\n     */\n    let prev = this;\n\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        //we have a loaded tile, we can discard the rest of the list\n        //we would could abort any LOADING tile request\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\n        tile.interimTile = null;\n        break;\n      } else if (tile.getState() == TileState.LOADING) {\n        //keep this LOADING tile any loaded tiles later in the chain are\n        //older than this tile, so we're still interested in the request\n        prev = tile;\n      } else if (tile.getState() == TileState.IDLE) {\n        //the head of the list is the most current tile, we don't need\n        //to start any other requests for this chain\n        prev.interimTile = tile.interimTile;\n      } else {\n        prev = tile;\n      }\n      tile = prev.interimTile;\n    } while (tile);\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenImage} from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   *\n   * @api\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this)\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n","/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  } else {\n    return new TileRange(minX, maxX, minY, maxY);\n  }\n}\n\nexport default TileRange;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     'change:source'|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   'change:source'|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true\n    );\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n","/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n","/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256)\n              )\n            )\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0]\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach(\n        function (triangle) {\n          if (\n            Math.max(\n              triangle.source[0][0],\n              triangle.source[1][0],\n              triangle.source[2][0]\n            ) -\n              leftBound >\n            this.sourceWorldWidth_ / 2\n          ) {\n            const newTriangle = [\n              [triangle.source[0][0], triangle.source[0][1]],\n              [triangle.source[1][0], triangle.source[1][1]],\n              [triangle.source[2][0], triangle.source[2][1]],\n            ];\n            if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[0][0] -= this.sourceWorldWidth_;\n            }\n            if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[1][0] -= this.sourceWorldWidth_;\n            }\n            if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[2][0] -= this.sourceWorldWidth_;\n            }\n\n            // Rarely (if the extent contains both the dateline and prime meridian)\n            // the shift can in turn break some triangles.\n            // Detect this here and don't shift in such cases.\n            const minX = Math.min(\n              newTriangle[0][0],\n              newTriangle[1][0],\n              newTriangle[2][0]\n            );\n            const maxX = Math.max(\n              newTriangle[0][0],\n              newTriangle[1][0],\n              newTriangle[2][0]\n            );\n            if (maxX - minX < this.sourceWorldWidth_ / 2) {\n              triangle.source = newTriangle;\n            }\n          }\n        }.bind(this)\n      );\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n","/**\n * @module ol/reproj\n */\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {getPointResolution, transform} from './proj.js';\nimport {solveLinearSystem} from './math.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = document.createElement('canvas').getContext('2d');\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  renderEdges,\n  interpolate\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height),\n    canvasPool\n  );\n\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  const canvasWidthInUnits = getWidth(sourceDataExtent);\n  const canvasHeightInUnits = getHeight(sourceDataExtent);\n  const stitchContext = createCanvasContext2D(\n    Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution),\n    Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution)\n  );\n\n  if (!interpolate) {\n    stitchContext.imageSmoothingEnabled = false;\n  }\n\n  const stitchScale = pixelRatio / sourceResolution;\n\n  sources.forEach(function (src, i, arr) {\n    const xPos = src.extent[0] - sourceDataExtent[0];\n    const yPos = -(src.extent[3] - sourceDataExtent[3]);\n    const srcWidth = getWidth(src.extent);\n    const srcHeight = getHeight(src.extent);\n\n    // This test should never fail -- but it does. Need to find a fix the upstream condition\n    if (src.image.width > 0 && src.image.height > 0) {\n      stitchContext.drawImage(\n        src.image,\n        gutter,\n        gutter,\n        src.image.width - 2 * gutter,\n        src.image.height - 2 * gutter,\n        xPos * stitchScale,\n        yPos * stitchScale,\n        srcWidth * stitchScale,\n        srcHeight * stitchScale\n      );\n    }\n  });\n\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1))\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1))\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY\n    );\n\n    context.scale(\n      sourceResolution / pixelRatio,\n      -sourceResolution / pixelRatio\n    );\n\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  if (renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n","/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {releaseCanvas} from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {boolean} [interpolate] Use linear interpolation when resampling.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    interpolate\n  ) {\n    super(tileCoord, TileState.IDLE, {interpolate: !!interpolate});\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach(\n      function (tile, i, arr) {\n        if (tile && tile.getState() == TileState.LOADED) {\n          sources.push({\n            extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n            image: tile.getImage(),\n          });\n        }\n      }.bind(this)\n    );\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(\n        function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE || state == TileState.LOADING) {\n            leftToLoad++;\n\n            const sourceListenKey = listen(\n              tile,\n              EventType.CHANGE,\n              function (e) {\n                const state = tile.getState();\n                if (\n                  state == TileState.LOADED ||\n                  state == TileState.ERROR ||\n                  state == TileState.EMPTY\n                ) {\n                  unlistenByKey(sourceListenKey);\n                  leftToLoad--;\n                  if (leftToLoad === 0) {\n                    this.unlistenSources_();\n                    this.reproject_();\n                  }\n                }\n              },\n              this\n            );\n            this.sourcesListenerKeys_.push(sourceListenKey);\n          }\n        }.bind(this)\n      );\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n","/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getHeight,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  getWidth,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {numberSafeCompareFunction} from '../../array.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(\n        z,\n        tileCoord[1],\n        tileCoord[2],\n        pixelRatio,\n        projection\n      );\n      if (\n        !(tile instanceof ImageTile || tile instanceof ReprojTile) ||\n        (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY)\n      ) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0])\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1])\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection)\n      );\n\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection)\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (\n          rotation &&\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n        ) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (\n              !this.newTiles_ &&\n              (inTransition || !this.renderedTiles.includes(tile))\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent\n          );\n        }\n      }\n    }\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2\n    );\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (\n                  intersects(\n                    [x, y, x + w, y + h],\n                    [clip[0], clip[3], clip[4], clip[7]]\n                  )\n                ) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition\n        );\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload()\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h\n    );\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../Map.js\").PostRenderFunction} */ (\n          postRenderFunction\n        )\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    tileCallback\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          frameState.viewState.center,\n          frameState.viewState.resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/layer/Tile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\n * @api\n */\nclass TileLayer extends BaseTileLayer {\n  /**\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  createRenderer() {\n    return new CanvasTileLayerRenderer(this);\n  }\n}\n\nexport default TileLayer;\n"],"names":["Tile","EventTarget","tileCoord","state","options","EventType","TileState","tile","prev","abstract","id","time","start","delta","easeIn","Tile$1","ImageTile","src","crossOrigin","tileLoadFunction","element","getBlankImage","image","listenImage","ctx","createCanvasContext2D","ImageTile$1","TileRange","minX","maxX","minY","maxY","tileRange","x","y","createOrUpdate","TileRange$1","TileProperty","BaseTileLayer","Layer","baseOptions","preload","useInterimTilesOnError","pixel","BaseTileLayer$1","ERROR_THRESHOLD","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","destinationResolution","transformInvCache","transformInv","getTransform","c","key","getWidth","destinationTopLeft","getTopLeft","destinationTopRight","getTopRight","destinationBottomRight","getBottomRight","destinationBottomLeft","getBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","getArea","leftBound","triangle","i","arr","newTriangle","a","b","aSrc","bSrc","cSrc","d","dSrc","sourceQuadExtent","boundingExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","targetQuadExtent","intersects","isNotFinite","center","centerSrc","dx","modulo","dy","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","extent","createEmpty","extendCoordinate","Triangulation$1","brokenDiagonalRendering_","canvasPool","drawTestTriangle","u1","v1","u2","v2","verifyBrokenDiagonalRendering","data","offset","isBrokenDiagonalRendering","calculateSourceResolution","targetCenter","targetResolution","sourceCenter","transform","sourceResolution","getPointResolution","targetMetersPerUnit","sourceMetersPerUnit","sourceExtent","containsCoordinate","compensationFactor","calculateSourceExtentResolution","getCenter","forEachCorner","corner","render","width","height","pixelRatio","triangulation","sources","gutter","renderEdges","interpolate","context","pixelRound","value","sourceDataExtent","extend","canvasWidthInUnits","canvasHeightInUnits","getHeight","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","targetTopLeft","source","target","x0","y0","x1","y1","x2","y2","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","solveLinearSystem","steps","ud","vd","step","ReprojTile","sourceTileGrid","targetTileGrid","wrappedTileCoord","getTileFunction","maxTargetExtent","limitedTargetExtent","getIntersection","sourceProjExtent","errorThresholdInPixels","clamp","sourceRange","srcX","srcY","z","size","renderReprojected","leftToLoad","sourceListenKey","listen","e","unlistenByKey","releaseCanvas","ReprojTile$1","CanvasTileLayerRenderer","CanvasLayerRenderer","tileLayer","tileState","frameState","projection","layer","coordinate","applyTransform","layerExtent","viewState","tileGrid","tilePixelRatio","tileOrigin","tileSize","toSize","tileResolution","col","row","tiles","zoom","layerState","viewResolution","viewCenter","rotation","tileSource","sourceRevision","resolution","fromUserExtent","canvasExtent","tilesToDrawByZ","findLoadedTiles","tmpExtent","tmpTileRange","viewport","getRotatedViewport","uid","getUid","inTransition","childTileRange","covered","canvasScale","composeTransform","canvasTransform","toTransformString","canvas","makeInverse","zs","numberSafeCompareFunction","clips","clipZs","currentClip","currentZ","currentTilePixelSize","currentScale","originTileCoord","originTileExtent","origin","tileGutter","tilesToDraw","tileCoordKey","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","equals","alpha","alphaChanged","postRenderFunction","map","tileSourceKey","usedTiles","tileCallback","wantedTiles","tileQueue","minZoom","tileCount","CanvasTileLayerRenderer$1","TileLayer","TileLayer$1"],"mappings":"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"}