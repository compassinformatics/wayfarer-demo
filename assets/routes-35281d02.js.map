{"version":3,"file":"routes-35281d02.js","sources":["../../node_modules/ol/structs/LRUCache.js","../../node_modules/ol/tilecoord.js","../../node_modules/ol/TileCache.js","../../node_modules/ol/source/TileEventType.js","../../node_modules/ol/tilegrid/TileGrid.js","../../node_modules/ol/tilegrid.js","../../node_modules/ol/source/Tile.js","../../node_modules/ol/tileurlfunction.js","../../node_modules/ol/source/UrlTile.js","../../node_modules/ol/source/TileImage.js","../../node_modules/ol/source/XYZ.js","../../node_modules/ol/source/OSM.js","../../src/js/routesolver.js","../../src/js/routes.js"],"sourcesContent":["/**\n * @module ol/structs/LRUCache\n */\n\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Object} newer Newer.\n * @property {Object} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.pop();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n    if (entry === this.newest_) {\n      return entry.value_;\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T} Value.\n   */\n  peek(key) {\n    if (!this.containsKey(key)) {\n      return undefined;\n    }\n    return this.entries_[key].value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n","/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  } else {\n    return [z, x, y];\n  }\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n    .split(',')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  } else {\n    return tileRange.containsXY(x, y);\n  }\n}\n","/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nclass TileCache extends LRUCache {\n  clear() {\n    while (this.getCount() > 0) {\n      this.pop().release();\n    }\n    super.clear();\n  }\n\n  /**\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      if (tile.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach(\n      function (tile) {\n        if (tile.tileCoord[0] !== z) {\n          this.remove(getKey(tile.tileCoord));\n          tile.release();\n        }\n      }.bind(this)\n    );\n  }\n}\n\nexport default TileCache;\n","/**\n * @module ol/source/TileEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a tile starts loading.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n   * @api\n   */\n  TILELOADSTART: 'tileloadstart',\n\n  /**\n   * Triggered when a tile finishes loading, either when its data is loaded,\n   * or when loading was aborted because the tile is no longer needed.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n   * @api\n   */\n  TILELOADEND: 'tileloadend',\n\n  /**\n   * Triggered if tile loading results in an error. Note that this is not the\n   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}\n   * for details.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n   * @api\n   */\n  TILELOADERROR: 'tileloaderror',\n};\n\n/**\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\n */\n","/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, {\n  createOrUpdate as createOrUpdateTileRange,\n} from '../TileRange.js';\nimport {DEFAULT_TILE_SIZE} from './common.js';\nimport {assert} from '../asserts.js';\nimport {ceil, clamp, floor} from '../math.js';\nimport {createOrUpdate, getTopLeft} from '../extent.js';\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\nimport {intersectsLinearRing} from '../geom/flat/intersectsextent.js';\nimport {isSorted, linearFindNearest} from '../array.js';\nimport {toSize} from '../size.js';\n\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nconst tmpTileCoord = [0, 0, 0];\n\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nconst DECIMALS = 5;\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nclass TileGrid {\n  /**\n   * @param {Options} options Tile grid options.\n   */\n  constructor(options) {\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n\n    /**\n     * @private\n     * @type {!Array<number>}\n     */\n    this.resolutions_ = options.resolutions;\n    assert(\n      isSorted(\n        this.resolutions_,\n        function (a, b) {\n          return b - a;\n        },\n        true\n      ),\n      17\n    ); // `resolutions` must be sorted in descending order\n\n    // check if we've got a consistent zoom factor and origin\n    let zoomFactor;\n    if (!options.origins) {\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n        if (!zoomFactor) {\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n        } else {\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n            zoomFactor = undefined;\n            break;\n          }\n        }\n      }\n    }\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.zoomFactor_ = zoomFactor;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxZoom = this.resolutions_.length - 1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.origin_ = options.origin !== undefined ? options.origin : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\n     */\n    this.origins_ = null;\n    if (options.origins !== undefined) {\n      this.origins_ = options.origins;\n      assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n    }\n\n    const extent = options.extent;\n\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\n      this.origin_ = getTopLeft(extent);\n    }\n\n    assert(\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n      18\n    ); // Either `origin` or `origins` must be configured, never both\n\n    /**\n     * @private\n     * @type {Array<number|import(\"../size.js\").Size>}\n     */\n    this.tileSizes_ = null;\n    if (options.tileSizes !== undefined) {\n      this.tileSizes_ = options.tileSizes;\n      assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n    }\n\n    /**\n     * @private\n     * @type {number|import(\"../size.js\").Size}\n     */\n    this.tileSize_ =\n      options.tileSize !== undefined\n        ? options.tileSize\n        : !this.tileSizes_\n        ? DEFAULT_TILE_SIZE\n        : null;\n    assert(\n      (!this.tileSize_ && this.tileSizes_) ||\n        (this.tileSize_ && !this.tileSizes_),\n      22\n    ); // Either `tileSize` or `tileSizes` must be configured, never both\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent !== undefined ? extent : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../TileRange.js\").default>}\n     */\n    this.fullTileRanges_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize_ = [0, 0];\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.tmpExtent_ = [0, 0, 0, 0];\n\n    if (options.sizes !== undefined) {\n      this.fullTileRanges_ = options.sizes.map(function (size, z) {\n        const tileRange = new TileRange(\n          Math.min(0, size[0]),\n          Math.max(size[0] - 1, -1),\n          Math.min(0, size[1]),\n          Math.max(size[1] - 1, -1)\n        );\n        if (extent) {\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n        }\n        return tileRange;\n      }, this);\n    } else if (extent) {\n      this.calculateTileRanges_(extent);\n    }\n  }\n\n  /**\n   * Call a function with each tile coordinate for a given extent and zoom level.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} zoom Integer zoom level.\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n   * @api\n   */\n  forEachTileCoord(extent, zoom, callback) {\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n        callback([zoom, i, j]);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {boolean} Callback succeeded.\n   */\n  forEachTileCoordParentTileRange(\n    tileCoord,\n    callback,\n    tempTileRange,\n    tempExtent\n  ) {\n    let tileRange, x, y;\n    let tileCoordExtent = null;\n    let z = tileCoord[0] - 1;\n    if (this.zoomFactor_ === 2) {\n      x = tileCoord[1];\n      y = tileCoord[2];\n    } else {\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);\n    }\n    while (z >= this.minZoom) {\n      if (this.zoomFactor_ === 2) {\n        x = Math.floor(x / 2);\n        y = Math.floor(y / 2);\n        tileRange = createOrUpdateTileRange(x, x, y, y, tempTileRange);\n      } else {\n        tileRange = this.getTileRangeForExtentAndZ(\n          tileCoordExtent,\n          z,\n          tempTileRange\n        );\n      }\n      if (callback(z, tileRange)) {\n        return true;\n      }\n      --z;\n    }\n    return false;\n  }\n\n  /**\n   * Get the extent for this tile grid, if it was configured.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the maximum zoom level for the grid.\n   * @return {number} Max zoom.\n   * @api\n   */\n  getMaxZoom() {\n    return this.maxZoom;\n  }\n\n  /**\n   * Get the minimum zoom level for the grid.\n   * @return {number} Min zoom.\n   * @api\n   */\n  getMinZoom() {\n    return this.minZoom;\n  }\n\n  /**\n   * Get the origin for the grid at the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\n   * @api\n   */\n  getOrigin(z) {\n    if (this.origin_) {\n      return this.origin_;\n    } else {\n      return this.origins_[z];\n    }\n  }\n\n  /**\n   * Get the resolution for the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {number} Resolution.\n   * @api\n   */\n  getResolution(z) {\n    return this.resolutions_[z];\n  }\n\n  /**\n   * Get the list of resolutions for the tile grid.\n   * @return {Array<number>} Resolutions.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\n   */\n  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {\n    if (tileCoord[0] < this.maxZoom) {\n      if (this.zoomFactor_ === 2) {\n        const minX = tileCoord[1] * 2;\n        const minY = tileCoord[2] * 2;\n        return createOrUpdateTileRange(\n          minX,\n          minX + 1,\n          minY,\n          minY + 1,\n          tempTileRange\n        );\n      }\n      const tileCoordExtent = this.getTileCoordExtent(\n        tileCoord,\n        tempExtent || this.tmpExtent_\n      );\n      return this.getTileRangeForExtentAndZ(\n        tileCoordExtent,\n        tileCoord[0] + 1,\n        tempTileRange\n      );\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\n   */\n  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {\n    if (z > this.maxZoom || z < this.minZoom) {\n      return null;\n    }\n\n    const tileCoordZ = tileCoord[0];\n    const tileCoordX = tileCoord[1];\n    const tileCoordY = tileCoord[2];\n\n    if (z === tileCoordZ) {\n      return createOrUpdateTileRange(\n        tileCoordX,\n        tileCoordY,\n        tileCoordX,\n        tileCoordY,\n        tempTileRange\n      );\n    }\n\n    if (this.zoomFactor_) {\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n      const minX = Math.floor(tileCoordX * factor);\n      const minY = Math.floor(tileCoordY * factor);\n      if (z < tileCoordZ) {\n        return createOrUpdateTileRange(minX, minX, minY, minY, tempTileRange);\n      }\n\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n      return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\n    }\n\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);\n  }\n\n  /**\n   * Get the extent for a tile range.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   */\n  getTileRangeExtent(z, tileRange, tempExtent) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n    const minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n    const maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n    const minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n    const maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\n  }\n\n  /**\n   * Get a tile range for the given extent and integer zoom level.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary tile range object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  getTileRangeForExtentAndZ(extent, z, tempTileRange) {\n    const tileCoord = tmpTileCoord;\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\n    const minX = tileCoord[1];\n    const minY = tileCoord[2];\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\n    return createOrUpdateTileRange(\n      minX,\n      tileCoord[1],\n      minY,\n      tileCoord[2],\n      tempTileRange\n    );\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n   */\n  getTileCoordCenter(tileCoord) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    return [\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n    ];\n  }\n\n  /**\n   * Get the extent of a tile coordinate.\n   *\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getTileCoordExtent(tileCoord, tempExtent) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n    const maxX = minX + tileSize[0] * resolution;\n    const maxY = minY + tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\n  }\n\n  /**\n   * Get the tile coordinate for the given map coordinate and resolution.  This\n   * method considers that coordinates that intersect tile boundaries should be\n   * assigned the higher tile coordinate.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\n    return this.getTileCoordForXYAndResolution_(\n      coordinate[0],\n      coordinate[1],\n      resolution,\n      false,\n      opt_tileCoord\n    );\n  }\n\n  /**\n   * Note that this method should not be called for resolutions that correspond\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} resolution Resolution (for a non-integer zoom level).\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndResolution_(\n    x,\n    y,\n    resolution,\n    reverseIntersectionPolicy,\n    opt_tileCoord\n  ) {\n    const z = this.getZForResolution(resolution);\n    const scale = resolution / this.getResolution(z);\n    const origin = this.getOrigin(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\n    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = floor(tileCoordX, DECIMALS);\n      tileCoordY = floor(tileCoordY, DECIMALS);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n   * they should have separate implementations.  This method is for integer zoom\n   * levels.  The other method should only be called for resolutions corresponding\n   * to non-integer zoom levels.\n   * @param {number} x Map x coordinate.\n   * @param {number} y Map y coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];\n    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = floor(tileCoordX, DECIMALS);\n      tileCoordY = floor(tileCoordY, DECIMALS);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Get a tile coordinate given a map coordinate and zoom level.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} z Zoom level.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\n    return this.getTileCoordForXYAndZ_(\n      coordinate[0],\n      coordinate[1],\n      z,\n      false,\n      opt_tileCoord\n    );\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {number} Tile resolution.\n   */\n  getTileCoordResolution(tileCoord) {\n    return this.resolutions_[tileCoord[0]];\n  }\n\n  /**\n   * Get the tile size for a zoom level. The type of the return value matches the\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n   * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\n   * @param {number} z Z.\n   * @return {number|import(\"../size.js\").Size} Tile size.\n   * @api\n   */\n  getTileSize(z) {\n    if (this.tileSize_) {\n      return this.tileSize_;\n    } else {\n      return this.tileSizes_[z];\n    }\n  }\n\n  /**\n   * @param {number} z Zoom level.\n   * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n   */\n  getFullTileRange(z) {\n    if (!this.fullTileRanges_) {\n      return this.extent_\n        ? this.getTileRangeForExtentAndZ(this.extent_, z)\n        : null;\n    } else {\n      return this.fullTileRanges_[z];\n    }\n  }\n\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\n   *     If 0, the nearest resolution will be used.\n   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\n   *     nearest lower resolution (higher Z) will be used. Default is 0.\n   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\n   *\n   * For example to change tile Z at the midpoint of zoom levels\n   * ```js\n   * function(value, high, low) {\n   *   return value - low * Math.sqrt(high / low);\n   * }\n   * ```\n   * @return {number} Z.\n   * @api\n   */\n  getZForResolution(resolution, opt_direction) {\n    const z = linearFindNearest(\n      this.resolutions_,\n      resolution,\n      opt_direction || 0\n    );\n    return clamp(z, this.minZoom, this.maxZoom);\n  }\n\n  /**\n   * The tile with the provided tile coordinate intersects the given viewport.\n   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.\n   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.\n   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.\n   */\n  tileCoordIntersectsViewport(tileCoord, viewport) {\n    return intersectsLinearRing(\n      viewport,\n      0,\n      viewport.length,\n      2,\n      this.getTileCoordExtent(tileCoord)\n    );\n  }\n\n  /**\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n   * @private\n   */\n  calculateTileRanges_(extent) {\n    const length = this.resolutions_.length;\n    const fullTileRanges = new Array(length);\n    for (let z = this.minZoom; z < length; ++z) {\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n    }\n    this.fullTileRanges_ = fullTileRanges;\n  }\n}\n\nexport default TileGrid;\n","/**\n * @module ol/tilegrid\n */\nimport TileGrid from './tilegrid/TileGrid.js';\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\nimport {\n  containsCoordinate,\n  createOrUpdate,\n  getCorner,\n  getHeight,\n  getWidth,\n} from './extent.js';\nimport {toSize} from './size.js';\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  let tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  const z = tileCoord[0];\n  const center = tileGrid.getTileCoordCenter(tileCoord);\n  const projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.ceil(\n      (projectionExtent[0] - center[0]) / worldWidth\n    );\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  } else {\n    return tileCoord;\n  }\n}\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, maxZoom, tileSize, corner) {\n  corner = corner !== undefined ? corner : 'top-left';\n\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: tileSize,\n  });\n}\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(options) {\n  const xyzOptions = options || {};\n\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  const gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize,\n      xyzOptions.maxResolution\n    ),\n  };\n  return new TileGrid(gridOptions);\n}\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\n  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;\n  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);\n\n  const height = getHeight(extent);\n  const width = getWidth(extent);\n\n  maxResolution =\n    maxResolution > 0\n      ? maxResolution\n      : Math.max(width / tileSize[0], height / tileSize[1]);\n\n  const length = maxZoom + 1;\n  const resolutions = new Array(length);\n  for (let z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, maxZoom, tileSize, corner) {\n  const extent = extentFromProjection(projection);\n  return createForExtent(extent, maxZoom, tileSize, corner);\n}\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  let extent = projection.getExtent();\n  if (!extent) {\n    const half =\n      (180 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n","/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport Source from './Source.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport {abstract} from '../util.js';\nimport {assert} from '../asserts.js';\nimport {equivalent} from '../proj.js';\nimport {getKeyZXY, withinExtentAndZ} from '../tilecoord.js';\nimport {\n  getForProjection as getTileGridForProjection,\n  wrapX,\n} from '../tilegrid.js';\nimport {scale as scaleSize, toSize} from '../size.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] CacheSize.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n * @abstract\n * @api\n */\nclass TileSource extends Source {\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n      interpolate: options.interpolate,\n    });\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TileSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ =\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n\n    /**\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n\n    const tileSize = [256, 256];\n    if (this.tileGrid) {\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\n    }\n\n    /**\n     * @protected\n     * @type {import(\"../TileCache.js\").default}\n     */\n    this.tileCache = new TileCache(options.cacheSize || 0);\n\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize = [0, 0];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = options.key || '';\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    this.tileOptions = {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    };\n\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = options.zDirection ? options.zDirection : 0;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.tileCache.canExpireCache();\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (tileCache) {\n      tileCache.expireCache(usedTiles);\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {number} z Zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\n   *     loaded tile.  If the callback returns `false`, the tile will not be\n   *     considered loaded.\n   * @return {boolean} The tile range is fully covered with loaded tiles.\n   */\n  forEachLoadedTile(projection, z, tileRange, callback) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (!tileCache) {\n      return false;\n    }\n\n    let covered = true;\n    let tile, tileCoordKey, loaded;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        tileCoordKey = getKeyZXY(z, x, y);\n        loaded = false;\n        if (tileCache.containsKey(tileCoordKey)) {\n          tile = /** @type {!import(\"../Tile.js\").default} */ (\n            tileCache.get(tileCoordKey)\n          );\n          loaded = tile.getState() === TileState.LOADED;\n          if (loaded) {\n            loaded = callback(tile) !== false;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n  getKey() {\n    return this.key_;\n  }\n\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n  getOpaque(projection) {\n    return this.opaque_;\n  }\n\n  /**\n   * @return {Array<number>|null} Resolutions.\n   */\n  getResolutions() {\n    if (!this.tileGrid) {\n      return null;\n    }\n    return this.tileGrid.getResolutions();\n  }\n\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\n   * @api\n   */\n  getTileGrid() {\n    return this.tileGrid;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    } else {\n      return this.tileGrid;\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   * @protected\n   */\n  getTileCacheForProjection(projection) {\n    const sourceProjection = this.getProjection();\n    assert(\n      sourceProjection === null || equivalent(sourceProjection, projection),\n      68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.\n    );\n    return this.tileCache;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    } else {\n      return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n    }\n  }\n\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\n    projection = projection !== undefined ? projection : this.getProjection();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (this.getWrapX() && projection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  }\n\n  /**\n   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\n   * @api\n   */\n  clear() {\n    this.tileCache.clear();\n  }\n\n  refresh() {\n    this.clear();\n    super.refresh();\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  updateCacheSize(tileCount, projection) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (tileCount > tileCache.highWaterMark) {\n      tileCache.highWaterMark = tileCount;\n    }\n  }\n\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  useTile(z, x, y, projection) {}\n}\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nexport class TileSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  constructor(type, tile) {\n    super(type);\n\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    this.tile = tile;\n  }\n}\n\nexport default TileSource;\n","/**\n * @module ol/tileurlfunction\n */\nimport {assert} from './asserts.js';\nimport {modulo} from './math.js';\nimport {hash as tileCoordHash} from './tilecoord.js';\n\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n  const zRegEx = /\\{z\\}/g;\n  const xRegEx = /\\{x\\}/g;\n  const yRegEx = /\\{y\\}/g;\n  const dashYRegEx = /\\{-y\\}/g;\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        return template\n          .replace(zRegEx, tileCoord[0].toString())\n          .replace(xRegEx, tileCoord[1].toString())\n          .replace(yRegEx, tileCoord[2].toString())\n          .replace(dashYRegEx, function () {\n            const z = tileCoord[0];\n            const range = tileGrid.getFullTileRange(z);\n            assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n            const y = range.getHeight() - tileCoord[2] - 1;\n            return y.toString();\n          });\n      }\n    }\n  );\n}\n\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n  const len = templates.length;\n  const tileUrlFunctions = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n  }\n  return createFromTileUrlFunctions(tileUrlFunctions);\n}\n\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n  if (tileUrlFunctions.length === 1) {\n    return tileUrlFunctions[0];\n  }\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        const h = tileCoordHash(tileCoord);\n        const index = modulo(h, tileUrlFunctions.length);\n        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n      }\n    }\n  );\n}\n\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n  return undefined;\n}\n\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n  const urls = [];\n  let match = /\\{([a-z])-([a-z])\\}/.exec(url);\n  if (match) {\n    // char range\n    const startCharCode = match[1].charCodeAt(0);\n    const stopCharCode = match[2].charCodeAt(0);\n    let charCode;\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n    }\n    return urls;\n  }\n  match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n  if (match) {\n    // number range\n    const stop = parseInt(match[2], 10);\n    for (let i = parseInt(match[1], 10); i <= stop; i++) {\n      urls.push(url.replace(match[0], i.toString()));\n    }\n    return urls;\n  }\n  urls.push(url);\n  return urls;\n}\n","/**\n * @module ol/source/UrlTile\n */\nimport TileEventType from './TileEventType.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileState from '../TileState.js';\nimport {createFromTemplates, expandUrl} from '../tileurlfunction.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Cache size.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction TileLoadFunction.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] TileUrlFunction.\n * @property {string} [url] Url.\n * @property {Array<string>} [urls] Urls.\n * @property {boolean} [wrapX=true] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Base class for sources providing tiles divided into a tile grid over http.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n */\nclass UrlTile extends TileSource {\n  /**\n   * @param {Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.generateTileUrlFunction_ =\n      this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction = options.tileLoadFunction;\n\n    if (options.tileUrlFunction) {\n      this.tileUrlFunction = options.tileUrlFunction;\n    }\n\n    /**\n     * @protected\n     * @type {!Array<string>|null}\n     */\n    this.urls = null;\n\n    if (options.urls) {\n      this.setUrls(options.urls);\n    } else if (options.url) {\n      this.setUrl(options.url);\n    }\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n  }\n\n  /**\n   * Return the tile load function of the source.\n   * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\n   * @api\n   */\n  getTileLoadFunction() {\n    return this.tileLoadFunction;\n  }\n\n  /**\n   * Return the tile URL function of the source.\n   * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\n   * @api\n   */\n  getTileUrlFunction() {\n    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction\n      ? this.tileUrlFunction.bind(this)\n      : this.tileUrlFunction;\n  }\n\n  /**\n   * Return the URLs used for this source.\n   * When a tileUrlFunction is used instead of url or urls,\n   * null will be returned.\n   * @return {!Array<string>|null} URLs.\n   * @api\n   */\n  getUrls() {\n    return this.urls;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleTileChange(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n          ? TileEventType.TILELOADEND\n          : undefined;\n    }\n    if (type != undefined) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * Set the tile load function of the source.\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @api\n   */\n  setTileLoadFunction(tileLoadFunction) {\n    this.tileCache.clear();\n    this.tileLoadFunction = tileLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * Set the tile URL function of the source.\n   * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\n   * @param {string} [key] Optional new tile key for the source.\n   * @api\n   */\n  setTileUrlFunction(tileUrlFunction, key) {\n    this.tileUrlFunction = tileUrlFunction;\n    this.tileCache.pruneExceptNewestZ();\n    if (typeof key !== 'undefined') {\n      this.setKey(key);\n    } else {\n      this.changed();\n    }\n  }\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string} url URL.\n   * @api\n   */\n  setUrl(url) {\n    const urls = expandUrl(url);\n    this.urls = urls;\n    this.setUrls(urls);\n  }\n\n  /**\n   * Set the URLs to use for requests.\n   * @param {Array<string>} urls URLs.\n   * @api\n   */\n  setUrls(urls) {\n    this.urls = urls;\n    const key = urls.join('\\n');\n    if (this.generateTileUrlFunction_) {\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n    } else {\n      this.setKey(key);\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {string|undefined} Tile URL.\n   */\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\n    return undefined;\n  }\n\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   */\n  useTile(z, x, y) {\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  }\n}\n\nexport default UrlTile;\n","/**\n * @module ol/source/TileImage\n */\nimport EventType from '../events/EventType.js';\nimport ImageTile from '../ImageTile.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport {getKey, getKeyZXY} from '../tilecoord.js';\nimport {getForProjection as getTileGridForProjection} from '../tilegrid.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\n * service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\n * request out-of-bounds tiles from the server. When set to `false`, only one\n * world will be rendered. When set to `true`, tiles will be requested for one\n * world only, but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [key] Optional tile key for proper cache fetching\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Base class for sources providing images divided into a tile grid.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass TileImage extends UrlTile {\n  /**\n   * @param {!Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultTileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate:\n        options.interpolate !== undefined ? options.interpolate : true,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @protected\n     * @type {?string}\n     */\n    this.crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @protected\n     * @type {typeof ImageTile}\n     */\n    this.tileClass =\n      options.tileClass !== undefined ? options.tileClass : ImageTile;\n\n    /**\n     * @protected\n     * @type {!Object<string, TileCache>}\n     */\n    this.tileCacheForProjection = {};\n\n    /**\n     * @protected\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection = {};\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderReprojectionEdges_ = false;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    if (this.tileCache.canExpireCache()) {\n      return true;\n    } else {\n      for (const key in this.tileCacheForProjection) {\n        if (this.tileCacheForProjection[key].canExpireCache()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    const usedTileCache = this.getTileCacheForProjection(projection);\n\n    this.tileCache.expireCache(\n      this.tileCache == usedTileCache ? usedTiles : {}\n    );\n    for (const id in this.tileCacheForProjection) {\n      const tileCache = this.tileCacheForProjection[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    if (\n      this.getProjection() &&\n      projection &&\n      !equivalent(this.getProjection(), projection)\n    ) {\n      return 0;\n    } else {\n      return this.getGutter();\n    }\n  }\n\n  /**\n   * @return {number} Gutter.\n   */\n  getGutter() {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n  getKey() {\n    let key = super.getKey();\n    if (!this.getInterpolate()) {\n      key += ':disable-interpolation';\n    }\n    return key;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n  getOpaque(projection) {\n    if (\n      this.getProjection() &&\n      projection &&\n      !equivalent(this.getProjection(), projection)\n    ) {\n      return false;\n    } else {\n      return super.getOpaque(projection);\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    } else {\n      const projKey = getUid(projection);\n      if (!(projKey in this.tileGridForProjection)) {\n        this.tileGridForProjection[projKey] =\n          getTileGridForProjection(projection);\n      }\n      return this.tileGridForProjection[projKey];\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   */\n  getTileCacheForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.tileCache;\n    } else {\n      const projKey = getUid(projection);\n      if (!(projKey in this.tileCacheForProjection)) {\n        this.tileCacheForProjection[projKey] = new TileCache(\n          this.tileCache.highWaterMark\n        );\n      }\n      return this.tileCacheForProjection[projKey];\n    }\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {string} key The key set on the tile.\n   * @return {!ImageTile} Tile.\n   * @private\n   */\n  createTile_(z, x, y, pixelRatio, projection, key) {\n    const tileCoord = [z, x, y];\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection\n    );\n    const tileUrl = urlTileCoord\n      ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)\n      : undefined;\n    const tile = new this.tileClass(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.crossOrigin,\n      this.tileLoadFunction,\n      this.tileOptions\n    );\n    tile.key = key;\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!(ImageTile|ReprojTile)} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      !sourceProjection ||\n      !projection ||\n      equivalent(sourceProjection, projection)\n    ) {\n      return this.getTileInternal(\n        z,\n        x,\n        y,\n        pixelRatio,\n        sourceProjection || projection\n      );\n    } else {\n      const cache = this.getTileCacheForProjection(projection);\n      const tileCoord = [z, x, y];\n      let tile;\n      const tileCoordKey = getKey(tileCoord);\n      if (cache.containsKey(tileCoordKey)) {\n        tile = cache.get(tileCoordKey);\n      }\n      const key = this.getKey();\n      if (tile && tile.key == key) {\n        return tile;\n      } else {\n        const sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n        const targetTileGrid = this.getTileGridForProjection(projection);\n        const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n          tileCoord,\n          projection\n        );\n        const newTile = new ReprojTile(\n          sourceProjection,\n          sourceTileGrid,\n          projection,\n          targetTileGrid,\n          tileCoord,\n          wrappedTileCoord,\n          this.getTilePixelRatio(pixelRatio),\n          this.getGutter(),\n          function (z, x, y, pixelRatio) {\n            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);\n          }.bind(this),\n          this.reprojectionErrorThreshold_,\n          this.renderReprojectionEdges_,\n          this.getInterpolate()\n        );\n        newTile.key = key;\n\n        if (tile) {\n          newTile.interimTile = tile;\n          newTile.refreshInterimChain();\n          cache.replace(tileCoordKey, newTile);\n        } else {\n          cache.set(tileCoordKey, newTile);\n        }\n        return newTile;\n      }\n    }\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {!import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!(ImageTile|ReprojTile)} Tile.\n   * @protected\n   */\n  getTileInternal(z, x, y, pixelRatio, projection) {\n    let tile = null;\n    const tileCoordKey = getKeyZXY(z, x, y);\n    const key = this.getKey();\n    if (!this.tileCache.containsKey(tileCoordKey)) {\n      tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n      this.tileCache.set(tileCoordKey, tile);\n    } else {\n      tile = this.tileCache.get(tileCoordKey);\n      if (tile.key != key) {\n        // The source's params changed. If the tile has an interim tile and if we\n        // can use it then we use it. Otherwise we create a new tile.  In both\n        // cases we attempt to assign an interim tile to the new tile.\n        const interimTile = tile;\n        tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n\n        //make the new tile the head of the list,\n        if (interimTile.getState() == TileState.IDLE) {\n          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it\n          tile.interimTile = interimTile.interimTile;\n        } else {\n          tile.interimTile = interimTile;\n        }\n        tile.refreshInterimChain();\n        this.tileCache.replace(tileCoordKey, tile);\n      }\n    }\n    return tile;\n  }\n\n  /**\n   * Sets whether to render reprojection edges or not (usually for debugging).\n   * @param {boolean} render Render the edges.\n   * @api\n   */\n  setRenderReprojectionEdges(render) {\n    if (this.renderReprojectionEdges_ == render) {\n      return;\n    }\n    this.renderReprojectionEdges_ = render;\n    for (const id in this.tileCacheForProjection) {\n      this.tileCacheForProjection[id].clear();\n    }\n    this.changed();\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection)) {\n        this.tileGridForProjection[projKey] = tilegrid;\n      }\n    }\n  }\n\n  clear() {\n    super.clear();\n    for (const id in this.tileCacheForProjection) {\n      this.tileCacheForProjection[id].clear();\n    }\n  }\n}\n\n/**\n * @param {ImageTile} imageTile Image tile.\n * @param {string} src Source.\n */\nfunction defaultTileLoadFunction(imageTile, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src =\n    src;\n}\n\nexport default TileImage;\n","/**\n * @module ol/source/XYZ\n */\n\nimport TileImage from './TileImage.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\n * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n * Not used if `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported images should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get\n * tile URL given a tile coordinate and the projection.\n * Required if `url` or `urls` are not provided.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,\n * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,\n * may be used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data with URLs in a set XYZ format that are\n * defined in a URL template. By default, this follows the widely-used\n * Google grid where `x` 0 and `y` 0 are in the top left. Grids like\n * TMS where `x` 0 and `y` 0 are in the bottom left can be used by\n * using the `{-y}` placeholder in the URL template, so long as the\n * source does not have a custom tile grid. In this case\n * a `tileUrlFunction` can be used, such as:\n * ```js\n *  tileUrlFunction: function(coordinate) {\n *    return 'http://mapserver.com/' + coordinate[0] + '/' +\n *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';\n *  }\n * ```\n * @api\n */\nclass XYZ extends TileImage {\n  /**\n   * @param {Options} [options] XYZ options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    const projection =\n      options.projection !== undefined ? options.projection : 'EPSG:3857';\n\n    const tileGrid =\n      options.tileGrid !== undefined\n        ? options.tileGrid\n        : createXYZ({\n            extent: extentFromProjection(projection),\n            maxResolution: options.maxResolution,\n            maxZoom: options.maxZoom,\n            minZoom: options.minZoom,\n            tileSize: options.tileSize,\n          });\n\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      opaque: options.opaque,\n      projection: projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n  }\n\n  /**\n   * @return {number} Gutter.\n   */\n  getGutter() {\n    return this.gutter_;\n  }\n}\n\nexport default XYZ;\n","/**\n * @module ol/source/OSM\n */\n\nimport XYZ from './XYZ.js';\n\n/**\n * The attribution containing a link to the OpenStreetMap Copyright and License\n * page.\n * @const\n * @type {string}\n * @api\n */\nexport const ATTRIBUTION =\n  '&#169; ' +\n  '<a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">OpenStreetMap</a> ' +\n  'contributors.';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {number} [maxZoom=19] Max zoom.\n * @property {boolean} [opaque=true] Whether the layer is opaque.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [url='https://tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.\n * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for the OpenStreetMap tile server.\n * @api\n */\nclass OSM extends XYZ {\n  /**\n   * @param {Options} [options] Open Street Map options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    let attributions;\n    if (options.attributions !== undefined) {\n      attributions = options.attributions;\n    } else {\n      attributions = [ATTRIBUTION];\n    }\n\n    const crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\n\n    const url =\n      options.url !== undefined\n        ? options.url\n        : 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';\n\n    super({\n      attributions: attributions,\n      attributionsCollapsible: false,\n      cacheSize: options.cacheSize,\n      crossOrigin: crossOrigin,\n      interpolate: options.interpolate,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,\n      opaque: options.opaque !== undefined ? options.opaque : true,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileLoadFunction: options.tileLoadFunction,\n      transition: options.transition,\n      url: url,\n      wrapX: options.wrapX,\n      zDirection: options.zDirection,\n    });\n  }\n}\n\nexport default OSM;\n","import { buffer, boundingExtent } from 'ol/extent.js'\nimport { primaryAction } from 'ol/events/condition.js'\nimport { Draw, Select } from 'ol/interaction.js'\nimport VectorLayer from 'ol/layer/Vector.js'\nimport VectorSource from 'ol/source/Vector.js'\nimport { Fill, Stroke, Style, Circle, Text } from 'ol/style.js'\nimport { getNetworkEdits } from './networkeditor.js'\nimport GeoJSON from 'ol/format/GeoJSON.js'\nimport { callService } from './utils.js'\nimport { updateTable } from './table.js'\n\nlet selectInteraction\n\nexport function clearRoutes () {\n    // clear all previous features so only the last drawn feature remains\n    resultsLayer.getSource().clear()\n}\n\nfunction resultsStyle (feature, resolution) {\n    let text\n\n    if (feature.getGeometry().getType() === 'LineString') {\n        text = new Text({\n            // text: feature.get('index').toString(),\n            font: '10px Open Sans',\n            fill: new Fill({ color: '#000' }),\n            stroke: new Stroke({ color: '#fff', width: 3 }),\n            offsetX: 0,\n            offsetY: -12,\n            textAlign: 'center',\n            textBaseline: 'middle'\n        })\n    } else {\n        text = new Text({\n            text: feature.get('index').toString(),\n            font: '14px Open Sans',\n            // fill: new Fill({ color: '#000' }),\n            // stroke: new Stroke({ color: '#000', width: 3 }),\n            offsetX: 0,\n            offsetY: 0,\n            textAlign: 'center',\n            textBaseline: 'middle'\n        })\n    }\n\n    return new Style({\n\n        stroke: new Stroke({\n            color: '#ff1dce',\n            width: 2\n        }),\n\n        text,\n\n        image: new Circle({\n            radius: 12,\n            fill: new Fill({\n                color: '#ff1dce'\n            })\n        })\n    })\n};\n\nconst resultsLayer = new VectorLayer({\n    source: new VectorSource(),\n    style: resultsStyle\n})\n\nfunction clearPreviousFeatures () {\n    // remove any previous edges from the results layer\n\n    resultsLayer.getSource().forEachFeature(function (feature) {\n        if (feature.getGeometry().getType() === 'LineString') {\n            // Remove the feature from the layer\n            resultsLayer.getSource().removeFeature(feature)\n        }\n    })\n}\n\nfunction isFeatureSnapped (map, coord, searchLayer) {\n    let extent = boundingExtent([coord]) // still a single point\n    const bufferDistance = map.getView().getResolution() * 3 // use a 6 pixel tolerance for snapping\n    extent = buffer(extent, bufferDistance) // buffer the point\n\n    const feats = searchLayer.getSource().getFeaturesInExtent(extent)\n\n    if (feats.length > 0) {\n        return true\n    } else {\n        return false\n    }\n}\n\nfunction serviceCallback (data) {\n    // load route from the GeoJSON\n\n    if (Object.keys(data).length !== 0) {\n        clearPreviousFeatures()\n        const geojsonFormat = new GeoJSON()\n        const feats = geojsonFormat.readFeatures(data)\n        resultsLayer.getSource().addFeatures(feats)\n\n        updateTable(feats, selectInteraction, resultsLayer)\n    }\n}\n\nfunction drawEnd (evt, networkLayer, resultsLayer) {\n    const feature = evt.feature\n    const coordinate = feature.getGeometry().getCoordinates()\n    const closestNetworkFeature = networkLayer.getSource().getClosestFeatureToCoordinate(coordinate)\n\n    if (closestNetworkFeature) {\n        const index = getPointFeatures().length\n\n        const edgeId = closestNetworkFeature.getId()\n        feature.set('edgeId', edgeId)\n        feature.set('index', index)\n        return true\n    }\n\n    return false\n}\n\nfunction getPointFeatures () {\n    const pointFeatures = []\n\n    resultsLayer.getSource().forEachFeature(\n\n        function (feature) {\n            if (feature.getGeometry().getType() === 'Point') {\n                pointFeatures.push(feature)\n            }\n        }\n    )\n\n    return pointFeatures\n}\n\nfunction getRoute (resultsLayer) {\n    const pointFeatures = getPointFeatures()\n\n    if (pointFeatures.length >= 2) {\n        const geojsonFormat = new GeoJSON()\n\n        const jsonData = JSON.stringify({\n            points: geojsonFormat.writeFeatures(pointFeatures),\n            edits: getNetworkEdits()\n        })\n\n        callService('solve_shortest_path_from_points', jsonData, serviceCallback)\n    }\n}\n\nexport function createRouteSolver (map, networkLayer) {\n    map.addLayer(resultsLayer)\n\n    const draw = new Draw({\n        source: resultsLayer.getSource(),\n        type: 'Point',\n        condition: function (evt) {\n            if (primaryAction(evt) === true) {\n                return isFeatureSnapped(map, evt.coordinate, networkLayer)\n            } else {\n                return false\n            }\n        }\n    })\n\n    resultsLayer.getSource().on('addfeature', function (evt) {\n        if (evt.feature.getGeometry().getType() === 'Point') {\n            getRoute(resultsLayer)\n        }\n    })\n\n    selectInteraction = new Select({\n        layers: [resultsLayer],\n        style: function (feature, resolution) {\n            return new Style({\n                stroke: new Stroke({\n                    color: '#00ffff',\n                    width: 2\n                })\n            })\n        }\n    })\n    selectInteraction.setActive(false)\n\n    map.addInteraction(selectInteraction)\n\n    draw.on('drawend', function (evt) {\n        drawEnd(evt, networkLayer, resultsLayer)\n    })\n\n    return draw\n}\n","import '../style.css'\nimport { Map, View } from 'ol'\nimport TileLayer from 'ol/layer/Tile'\nimport OSM from 'ol/source/OSM'\nimport { Snap } from 'ol/interaction.js'\nimport { transformExtent } from 'ol/proj'\nimport { getCenter } from 'ol/extent'\n\nimport 'ol/ol.css'\nimport 'bootstrap/dist/css/bootstrap.min.css'\n\nimport ContextMenu from 'ol-contextmenu'\nimport 'ol-contextmenu/ol-contextmenu.css'\n\nimport { createRouteSolver, clearRoutes } from './routesolver.js'\nimport { createNetworkEditor, clearNetworkEdits } from './networkeditor.js'\nimport { createNetworkLayer, toggleLabels } from './networklayer.js'\n\nimport { createTable } from './table.js'\n\nfunction init () {\n    // const geojsonFile = './data/dublin.json'\n    // const bbox = [-700886.9046790214, 7045529.032412218, -695548.0308066505, 7048223.495319679]\n    // const background = '#1a2b39'\n\n    const geojsonFile = './data/stbrice.json'\n    const extent = [2.3314107610246633, 48.988440397479536, 2.4050093789098863, 49.01280894618151]\n    const bbox = transformExtent(extent, 'EPSG:4326', 'EPSG:3857')\n    const background = null\n    const networkLayer = createNetworkLayer(geojsonFile, background, 'rgba(255, 255, 255, 0.0)')\n\n    createTable()\n\n    const map = new Map({\n        target: 'map',\n        layers: [\n            new TileLayer({\n                source: new OSM()\n            }),\n            networkLayer\n        ],\n        view: new View({\n            center: getCenter(bbox),\n            extent: bbox, // constrains extent\n            zoom: 16\n        })\n    })\n\n    function disableTools () {\n        const tools = [routeSolver, networkEditor]\n        tools.forEach(function (tool) {\n            tool.setActive(false)\n        })\n    }\n    const contextmenuItems = [\n        {\n            text: 'Hide/Show Labels',\n            callback: toggleLabels\n        },\n        '-',\n        {\n            text: 'Activate Route Solver',\n            callback: function () {\n                disableTools()\n                routeSolver.setActive(true)\n            }\n        },\n        {\n            text: 'Clear Routes',\n            callback: clearRoutes\n        },\n        '-',\n        {\n            text: 'Activate Network Editor',\n            callback: function () {\n                disableTools()\n                networkEditor.setActive(true)\n            }\n        },\n        {\n            text: 'Clear Network Edits',\n            callback: clearNetworkEdits\n        },\n        '-'\n    ]\n\n    const contextmenu = new ContextMenu({\n        width: 170,\n        defaultItems: true, // defaultItems are (for now) Zoom In/Zoom Out\n        items: contextmenuItems\n    })\n    map.addControl(contextmenu)\n\n    const networkEditor = createNetworkEditor(map, networkLayer)\n    const routeSolver = createRouteSolver(map, networkLayer)\n\n    map.addInteraction(routeSolver)\n    map.addInteraction(networkEditor)\n\n    disableTools()\n    routeSolver.setActive(true)\n\n    const snap = new Snap({\n        source: networkLayer.getSource()\n    })\n\n    // The snap interaction must be added after the Modify and Draw interactions\n    // in order for its map browser event handlers to be fired first. Its handlers\n    // are responsible of doing the snapping.\n    map.addInteraction(snap)\n}\n\ninit()\n"],"names":["LRUCache","highWaterMark","keep","key","f","entry","options","assert","keys","i","values","value","size","LRUCache$1","createOrUpdate","z","x","y","tileCoord","getKeyZXY","getKey","fromKey","hash","withinExtentAndZ","tileGrid","tileRange","TileCache","usedTiles","tile","TileCache$1","TileEventType","tmpTileCoord","DECIMALS","TileGrid","isSorted","a","b","zoomFactor","ii","extent","getTopLeft","DEFAULT_TILE_SIZE","TileRange","restrictedTileRange","zoom","callback","j","jj","tempTileRange","tempExtent","tileCoordExtent","createOrUpdateTileRange","minX","minY","tileCoordZ","tileCoordX","tileCoordY","factor","maxX","maxY","origin","resolution","tileSize","toSize","coordinate","opt_tileCoord","reverseIntersectionPolicy","scale","ceil","floor","createOrUpdateTileCoord","opt_direction","linearFindNearest","clamp","viewport","intersectsLinearRing","length","fullTileRanges","TileGrid$1","getForProjection","projection","createForProjection","wrapX","center","projectionExtent","extentFromProjection","containsCoordinate","worldWidth","getWidth","worldsAway","createForExtent","maxZoom","corner","resolutions","resolutionsFromExtent","getCorner","createXYZ","xyzOptions","getProjection","gridOptions","maxResolution","DEFAULT_MAX_ZOOM","height","getHeight","width","half","METERS_PER_UNIT","TileSource","Source","tileCache","covered","tileCoordKey","loaded","TileState","pixelRatio","abstract","getTileGridForProjection","sourceProjection","equivalent","tilePixelRatio","scaleSize","tileCount","TileSourceEvent","Event","type","TileSource$1","createFromTemplate","template","zRegEx","xRegEx","yRegEx","dashYRegEx","range","createFromTemplates","templates","len","tileUrlFunctions","createFromTileUrlFunctions","h","tileCoordHash","index","modulo","expandUrl","url","urls","match","startCharCode","stopCharCode","charCode","stop","UrlTile","event","uid","getUid","tileState","tileLoadFunction","tileUrlFunction","UrlTile$1","TileImage","defaultTileLoadFunction","ImageTile","usedTileCache","id","thisProj","projKey","urlTileCoord","tileUrl","EventType","cache","sourceTileGrid","targetTileGrid","wrappedTileCoord","newTile","ReprojTile","interimTile","render","tilegrid","proj","imageTile","src","TileImage$1","XYZ","XYZ$1","ATTRIBUTION","OSM","attributions","crossOrigin","OSM$1","selectInteraction","clearRoutes","resultsLayer","resultsStyle","feature","text","Text","Fill","Stroke","Style","Circle","VectorLayer","VectorSource","clearPreviousFeatures","isFeatureSnapped","map","coord","searchLayer","boundingExtent","bufferDistance","buffer","serviceCallback","data","feats","GeoJSON","updateTable","drawEnd","evt","networkLayer","closestNetworkFeature","getPointFeatures","edgeId","pointFeatures","getRoute","geojsonFormat","jsonData","getNetworkEdits","callService","createRouteSolver","draw","Draw","primaryAction","Select","init","geojsonFile","bbox","transformExtent","createNetworkLayer","createTable","Map","TileLayer","View","getCenter","disableTools","routeSolver","networkEditor","tool","contextmenuItems","toggleLabels","clearNetworkEdits","contextmenu","ContextMenu","createNetworkEditor","snap","Snap"],"mappings":"yqBAuBA,MAAMA,EAAS,CAIb,YAAYC,EAAe,CAMzB,KAAK,cAAgBA,IAAkB,OAAYA,EAAgB,KAMnE,KAAK,OAAS,EAMd,KAAK,SAAW,GAMhB,KAAK,QAAU,KAMf,KAAK,QAAU,IAChB,CAKD,gBAAiB,CACf,OAAO,KAAK,cAAgB,GAAK,KAAK,SAAU,EAAG,KAAK,aACzD,CAMD,YAAYC,EAAM,CAChB,KAAO,KAAK,kBACV,KAAK,IAAG,CAEX,CAKD,OAAQ,CACN,KAAK,OAAS,EACd,KAAK,SAAW,GAChB,KAAK,QAAU,KACf,KAAK,QAAU,IAChB,CAMD,YAAYC,EAAK,CACf,OAAO,KAAK,SAAS,eAAeA,CAAG,CACxC,CAQD,QAAQC,EAAG,CACT,IAAIC,EAAQ,KAAK,QACjB,KAAOA,GACLD,EAAEC,EAAM,OAAQA,EAAM,KAAM,IAAI,EAChCA,EAAQA,EAAM,KAEjB,CAOD,IAAIF,EAAKG,EAAS,CAChB,MAAMD,EAAQ,KAAK,SAASF,CAAG,EAE/B,OADAI,EAAOF,IAAU,OAAW,EAAE,EAC1BA,IAAU,KAAK,UAERA,IAAU,KAAK,SACxB,KAAK,QAAgC,KAAK,QAAQ,MAClD,KAAK,QAAQ,MAAQ,OAErBA,EAAM,MAAM,MAAQA,EAAM,MAC1BA,EAAM,MAAM,MAAQA,EAAM,OAE5BA,EAAM,MAAQ,KACdA,EAAM,MAAQ,KAAK,QACnB,KAAK,QAAQ,MAAQA,EACrB,KAAK,QAAUA,GACRA,EAAM,MACd,CAOD,OAAOF,EAAK,CACV,MAAME,EAAQ,KAAK,SAASF,CAAG,EAC/B,OAAAI,EAAOF,IAAU,OAAW,EAAE,EAC1BA,IAAU,KAAK,SACjB,KAAK,QAAgCA,EAAM,MACvC,KAAK,UACP,KAAK,QAAQ,MAAQ,OAEdA,IAAU,KAAK,SACxB,KAAK,QAAgCA,EAAM,MACvC,KAAK,UACP,KAAK,QAAQ,MAAQ,QAGvBA,EAAM,MAAM,MAAQA,EAAM,MAC1BA,EAAM,MAAM,MAAQA,EAAM,OAE5B,OAAO,KAAK,SAASF,CAAG,EACxB,EAAE,KAAK,OACAE,EAAM,MACd,CAKD,UAAW,CACT,OAAO,KAAK,MACb,CAKD,SAAU,CACR,MAAMG,EAAO,IAAI,MAAM,KAAK,MAAM,EAClC,IAAIC,EAAI,EACJJ,EACJ,IAAKA,EAAQ,KAAK,QAASA,EAAOA,EAAQA,EAAM,MAC9CG,EAAKC,GAAG,EAAIJ,EAAM,KAEpB,OAAOG,CACR,CAKD,WAAY,CACV,MAAME,EAAS,IAAI,MAAM,KAAK,MAAM,EACpC,IAAID,EAAI,EACJJ,EACJ,IAAKA,EAAQ,KAAK,QAASA,EAAOA,EAAQA,EAAM,MAC9CK,EAAOD,GAAG,EAAIJ,EAAM,OAEtB,OAAOK,CACR,CAKD,UAAW,CACT,OAAO,KAAK,QAAQ,MACrB,CAKD,aAAc,CACZ,OAAO,KAAK,QAAQ,IACrB,CAMD,cAAe,CACb,OAAO,KAAK,QAAQ,IACrB,CAOD,KAAKP,EAAK,CACR,GAAK,KAAK,YAAYA,CAAG,EAGzB,OAAO,KAAK,SAASA,CAAG,EAAE,MAC3B,CAKD,KAAM,CACJ,MAAME,EAAQ,KAAK,QACnB,cAAO,KAAK,SAASA,EAAM,IAAI,EAC3BA,EAAM,QACRA,EAAM,MAAM,MAAQ,MAEtB,KAAK,QAAgCA,EAAM,MACtC,KAAK,UACR,KAAK,QAAU,MAEjB,EAAE,KAAK,OACAA,EAAM,MACd,CAMD,QAAQF,EAAKQ,EAAO,CAClB,KAAK,IAAIR,CAAG,EACZ,KAAK,SAASA,CAAG,EAAE,OAASQ,CAC7B,CAMD,IAAIR,EAAKQ,EAAO,CACdJ,EAAO,EAAEJ,KAAO,KAAK,UAAW,EAAE,EAClC,MAAME,EAAQ,CACZ,KAAMF,EACN,MAAO,KACP,MAAO,KAAK,QACZ,OAAQQ,CACd,EACS,KAAK,QAGR,KAAK,QAAQ,MAAQN,EAFrB,KAAK,QAAUA,EAIjB,KAAK,QAAUA,EACf,KAAK,SAASF,CAAG,EAAIE,EACrB,EAAE,KAAK,MACR,CAOD,QAAQO,EAAM,CACZ,KAAK,cAAgBA,CACtB,CACH,CAEA,MAAAC,GAAeb,GC3QR,SAASc,EAAeC,EAAGC,EAAGC,EAAGC,EAAW,CACjD,OAAIA,IAAc,QAChBA,EAAU,CAAC,EAAIH,EACfG,EAAU,CAAC,EAAIF,EACfE,EAAU,CAAC,EAAID,EACRC,GAEA,CAACH,EAAGC,EAAGC,CAAC,CAEnB,CAQO,SAASE,EAAUJ,EAAGC,EAAGC,EAAG,CACjC,OAAOF,EAAI,IAAMC,EAAI,IAAMC,CAC7B,CAOO,SAASG,EAAOF,EAAW,CAChC,OAAOC,EAAUD,EAAU,CAAC,EAAGA,EAAU,CAAC,EAAGA,EAAU,CAAC,CAAC,CAC3D,CAoBO,SAASG,GAAQlB,EAAK,CAC3B,OAAOA,EAAI,MAAM,GAAG,EAAE,IAAI,MAAM,CAClC,CAMO,SAASmB,GAAKJ,EAAW,CAC9B,OAAQA,EAAU,CAAC,GAAKA,EAAU,CAAC,GAAKA,EAAU,CAAC,CACrD,CAOO,SAASK,GAAiBL,EAAWM,EAAU,CACpD,MAAMT,EAAIG,EAAU,CAAC,EACfF,EAAIE,EAAU,CAAC,EACfD,EAAIC,EAAU,CAAC,EAErB,GAAIM,EAAS,aAAeT,GAAKA,EAAIS,EAAS,aAC5C,MAAO,GAET,MAAMC,EAAYD,EAAS,iBAAiBT,CAAC,EAC7C,OAAKU,EAGIA,EAAU,WAAWT,EAAGC,CAAC,EAFzB,EAIX,CC3FA,MAAMS,WAAkB1B,EAAS,CAC/B,OAAQ,CACN,KAAO,KAAK,SAAU,EAAG,GACvB,KAAK,MAAM,UAEb,MAAM,MAAK,CACZ,CAKD,YAAY2B,EAAW,CACrB,KAAO,KAAK,kBAEN,EADS,KAAK,WACT,OAAQ,IAAIA,IAGnB,KAAK,MAAM,SAGhB,CAKD,oBAAqB,CACnB,GAAI,KAAK,SAAU,IAAK,EACtB,OAEF,MAAMxB,EAAM,KAAK,eAEXY,EADYM,GAAQlB,CAAG,EACT,CAAC,EACrB,KAAK,QACH,SAAUyB,EAAM,CACVA,EAAK,UAAU,CAAC,IAAMb,IACxB,KAAK,OAAOK,EAAOQ,EAAK,SAAS,CAAC,EAClCA,EAAK,QAAO,EAEtB,EAAQ,KAAK,IAAI,CACjB,CACG,CACH,CAEA,MAAAC,EAAeH,GC1CAI,EAAA,CAMb,cAAe,gBAQf,YAAa,cASb,cAAe,eACjB,ECZMC,GAAe,CAAC,EAAG,EAAG,CAAC,EAMvBC,EAAW,EAuCjB,MAAMC,EAAS,CAIb,YAAY3B,EAAS,CAKnB,KAAK,QAAUA,EAAQ,UAAY,OAAYA,EAAQ,QAAU,EAMjE,KAAK,aAAeA,EAAQ,YAC5BC,EACE2B,EACE,KAAK,aACL,SAAUC,EAAGC,EAAG,CACd,OAAOA,EAAID,CACZ,EACD,EACD,EACD,EACN,EAGI,IAAIE,EACJ,GAAI,CAAC/B,EAAQ,SACX,QAASG,EAAI,EAAG6B,EAAK,KAAK,aAAa,OAAS,EAAG7B,EAAI6B,EAAI,EAAE7B,EAC3D,GAAI,CAAC4B,EACHA,EAAa,KAAK,aAAa5B,CAAC,EAAI,KAAK,aAAaA,EAAI,CAAC,UAEvD,KAAK,aAAaA,CAAC,EAAI,KAAK,aAAaA,EAAI,CAAC,IAAM4B,EAAY,CAClEA,EAAa,OACb,KACD,EASP,KAAK,YAAcA,EAMnB,KAAK,QAAU,KAAK,aAAa,OAAS,EAM1C,KAAK,QAAU/B,EAAQ,SAAW,OAAYA,EAAQ,OAAS,KAM/D,KAAK,SAAW,KACZA,EAAQ,UAAY,SACtB,KAAK,SAAWA,EAAQ,QACxBC,EAAO,KAAK,SAAS,QAAU,KAAK,aAAa,OAAQ,EAAE,GAG7D,MAAMgC,EAASjC,EAAQ,OAEnBiC,IAAW,QAAa,CAAC,KAAK,SAAW,CAAC,KAAK,WACjD,KAAK,QAAUC,EAAWD,CAAM,GAGlChC,EACG,CAAC,KAAK,SAAW,KAAK,UAAc,KAAK,SAAW,CAAC,KAAK,SAC3D,EACN,EAMI,KAAK,WAAa,KACdD,EAAQ,YAAc,SACxB,KAAK,WAAaA,EAAQ,UAC1BC,EAAO,KAAK,WAAW,QAAU,KAAK,aAAa,OAAQ,EAAE,GAO/D,KAAK,UACHD,EAAQ,WAAa,OACjBA,EAAQ,SACP,KAAK,WAEN,KADAmC,EAENlC,EACG,CAAC,KAAK,WAAa,KAAK,YACtB,KAAK,WAAa,CAAC,KAAK,WAC3B,EACN,EAMI,KAAK,QAAUgC,IAAW,OAAYA,EAAS,KAM/C,KAAK,gBAAkB,KAMvB,KAAK,SAAW,CAAC,EAAG,CAAC,EAMrB,KAAK,WAAa,CAAC,EAAG,EAAG,EAAG,CAAC,EAEzBjC,EAAQ,QAAU,OACpB,KAAK,gBAAkBA,EAAQ,MAAM,IAAI,SAAUM,EAAMG,EAAG,CAC1D,MAAMU,EAAY,IAAIiB,GACpB,KAAK,IAAI,EAAG9B,EAAK,CAAC,CAAC,EACnB,KAAK,IAAIA,EAAK,CAAC,EAAI,EAAG,EAAE,EACxB,KAAK,IAAI,EAAGA,EAAK,CAAC,CAAC,EACnB,KAAK,IAAIA,EAAK,CAAC,EAAI,EAAG,EAAE,CAClC,EACQ,GAAI2B,EAAQ,CACV,MAAMI,EAAsB,KAAK,0BAA0BJ,EAAQxB,CAAC,EACpEU,EAAU,KAAO,KAAK,IAAIkB,EAAoB,KAAMlB,EAAU,IAAI,EAClEA,EAAU,KAAO,KAAK,IAAIkB,EAAoB,KAAMlB,EAAU,IAAI,EAClEA,EAAU,KAAO,KAAK,IAAIkB,EAAoB,KAAMlB,EAAU,IAAI,EAClEA,EAAU,KAAO,KAAK,IAAIkB,EAAoB,KAAMlB,EAAU,IAAI,CACnE,CACD,OAAOA,CACR,EAAE,IAAI,EACEc,GACT,KAAK,qBAAqBA,CAAM,CAEnC,CAUD,iBAAiBA,EAAQK,EAAMC,EAAU,CACvC,MAAMpB,EAAY,KAAK,0BAA0Bc,EAAQK,CAAI,EAC7D,QAASnC,EAAIgB,EAAU,KAAMa,EAAKb,EAAU,KAAMhB,GAAK6B,EAAI,EAAE7B,EAC3D,QAASqC,EAAIrB,EAAU,KAAMsB,EAAKtB,EAAU,KAAMqB,GAAKC,EAAI,EAAED,EAC3DD,EAAS,CAACD,EAAMnC,EAAGqC,CAAC,CAAC,CAG1B,CASD,gCACE5B,EACA2B,EACAG,EACAC,EACA,CACA,IAAIxB,EAAWT,EAAGC,EACdiC,EAAkB,KAClBnC,EAAIG,EAAU,CAAC,EAAI,EAOvB,IANI,KAAK,cAAgB,GACvBF,EAAIE,EAAU,CAAC,EACfD,EAAIC,EAAU,CAAC,GAEfgC,EAAkB,KAAK,mBAAmBhC,EAAW+B,CAAU,EAE1DlC,GAAK,KAAK,SAAS,CAYxB,GAXI,KAAK,cAAgB,GACvBC,EAAI,KAAK,MAAMA,EAAI,CAAC,EACpBC,EAAI,KAAK,MAAMA,EAAI,CAAC,EACpBQ,EAAY0B,EAAwBnC,EAAGA,EAAGC,EAAGA,EAAG+B,CAAa,GAE7DvB,EAAY,KAAK,0BACfyB,EACAnC,EACAiC,CACV,EAEUH,EAAS9B,EAAGU,CAAS,EACvB,MAAO,GAET,EAAEV,CACH,CACD,MAAO,EACR,CAOD,WAAY,CACV,OAAO,KAAK,OACb,CAOD,YAAa,CACX,OAAO,KAAK,OACb,CAOD,YAAa,CACX,OAAO,KAAK,OACb,CAQD,UAAUA,EAAG,CACX,OAAI,KAAK,QACA,KAAK,QAEL,KAAK,SAASA,CAAC,CAEzB,CAQD,cAAcA,EAAG,CACf,OAAO,KAAK,aAAaA,CAAC,CAC3B,CAOD,gBAAiB,CACf,OAAO,KAAK,YACb,CAQD,2BAA2BG,EAAW8B,EAAeC,EAAY,CAC/D,GAAI/B,EAAU,CAAC,EAAI,KAAK,QAAS,CAC/B,GAAI,KAAK,cAAgB,EAAG,CAC1B,MAAMkC,EAAOlC,EAAU,CAAC,EAAI,EACtBmC,EAAOnC,EAAU,CAAC,EAAI,EAC5B,OAAOiC,EACLC,EACAA,EAAO,EACPC,EACAA,EAAO,EACPL,CACV,CACO,CACD,MAAME,EAAkB,KAAK,mBAC3BhC,EACA+B,GAAc,KAAK,UAC3B,EACM,OAAO,KAAK,0BACVC,EACAhC,EAAU,CAAC,EAAI,EACf8B,CACR,CACK,CACD,OAAO,IACR,CAQD,6BAA6B9B,EAAWH,EAAGiC,EAAe,CACxD,GAAIjC,EAAI,KAAK,SAAWA,EAAI,KAAK,QAC/B,OAAO,KAGT,MAAMuC,EAAapC,EAAU,CAAC,EACxBqC,EAAarC,EAAU,CAAC,EACxBsC,EAAatC,EAAU,CAAC,EAE9B,GAAIH,IAAMuC,EACR,OAAOH,EACLI,EACAC,EACAD,EACAC,EACAR,CACR,EAGI,GAAI,KAAK,YAAa,CACpB,MAAMS,EAAS,KAAK,IAAI,KAAK,YAAa1C,EAAIuC,CAAU,EAClDF,EAAO,KAAK,MAAMG,EAAaE,CAAM,EACrCJ,EAAO,KAAK,MAAMG,EAAaC,CAAM,EAC3C,GAAI1C,EAAIuC,EACN,OAAOH,EAAwBC,EAAMA,EAAMC,EAAMA,EAAML,CAAa,EAGtE,MAAMU,EAAO,KAAK,MAAMD,GAAUF,EAAa,EAAE,EAAI,EAC/CI,EAAO,KAAK,MAAMF,GAAUD,EAAa,EAAE,EAAI,EACrD,OAAOL,EAAwBC,EAAMM,EAAML,EAAMM,EAAMX,CAAa,CACrE,CAED,MAAME,EAAkB,KAAK,mBAAmBhC,EAAW,KAAK,UAAU,EAC1E,OAAO,KAAK,0BAA0BgC,EAAiBnC,EAAGiC,CAAa,CACxE,CASD,mBAAmBjC,EAAGU,EAAWwB,EAAY,CAC3C,MAAMW,EAAS,KAAK,UAAU7C,CAAC,EACzB8C,EAAa,KAAK,cAAc9C,CAAC,EACjC+C,EAAWC,EAAO,KAAK,YAAYhD,CAAC,EAAG,KAAK,QAAQ,EACpDqC,EAAOQ,EAAO,CAAC,EAAInC,EAAU,KAAOqC,EAAS,CAAC,EAAID,EAClDH,EAAOE,EAAO,CAAC,GAAKnC,EAAU,KAAO,GAAKqC,EAAS,CAAC,EAAID,EACxDR,EAAOO,EAAO,CAAC,EAAInC,EAAU,KAAOqC,EAAS,CAAC,EAAID,EAClDF,EAAOC,EAAO,CAAC,GAAKnC,EAAU,KAAO,GAAKqC,EAAS,CAAC,EAAID,EAC9D,OAAO/C,EAAesC,EAAMC,EAAMK,EAAMC,EAAMV,CAAU,CACzD,CASD,0BAA0BV,EAAQxB,EAAGiC,EAAe,CAClD,MAAM9B,EAAYa,GAClB,KAAK,uBAAuBQ,EAAO,CAAC,EAAGA,EAAO,CAAC,EAAGxB,EAAG,GAAOG,CAAS,EACrE,MAAMkC,EAAOlC,EAAU,CAAC,EAClBmC,EAAOnC,EAAU,CAAC,EACxB,YAAK,uBAAuBqB,EAAO,CAAC,EAAGA,EAAO,CAAC,EAAGxB,EAAG,GAAMG,CAAS,EAC7DiC,EACLC,EACAlC,EAAU,CAAC,EACXmC,EACAnC,EAAU,CAAC,EACX8B,CACN,CACG,CAMD,mBAAmB9B,EAAW,CAC5B,MAAM0C,EAAS,KAAK,UAAU1C,EAAU,CAAC,CAAC,EACpC2C,EAAa,KAAK,cAAc3C,EAAU,CAAC,CAAC,EAC5C4C,EAAWC,EAAO,KAAK,YAAY7C,EAAU,CAAC,CAAC,EAAG,KAAK,QAAQ,EACrE,MAAO,CACL0C,EAAO,CAAC,GAAK1C,EAAU,CAAC,EAAI,IAAO4C,EAAS,CAAC,EAAID,EACjDD,EAAO,CAAC,GAAK1C,EAAU,CAAC,EAAI,IAAO4C,EAAS,CAAC,EAAID,CACvD,CACG,CAUD,mBAAmB3C,EAAW+B,EAAY,CACxC,MAAMW,EAAS,KAAK,UAAU1C,EAAU,CAAC,CAAC,EACpC2C,EAAa,KAAK,cAAc3C,EAAU,CAAC,CAAC,EAC5C4C,EAAWC,EAAO,KAAK,YAAY7C,EAAU,CAAC,CAAC,EAAG,KAAK,QAAQ,EAC/DkC,EAAOQ,EAAO,CAAC,EAAI1C,EAAU,CAAC,EAAI4C,EAAS,CAAC,EAAID,EAChDR,EAAOO,EAAO,CAAC,GAAK1C,EAAU,CAAC,EAAI,GAAK4C,EAAS,CAAC,EAAID,EACtDH,EAAON,EAAOU,EAAS,CAAC,EAAID,EAC5BF,EAAON,EAAOS,EAAS,CAAC,EAAID,EAClC,OAAO/C,EAAesC,EAAMC,EAAMK,EAAMC,EAAMV,CAAU,CACzD,CAaD,kCAAkCe,EAAYH,EAAYI,EAAe,CACvE,OAAO,KAAK,gCACVD,EAAW,CAAC,EACZA,EAAW,CAAC,EACZH,EACA,GACAI,CACN,CACG,CAeD,gCACEjD,EACAC,EACA4C,EACAK,EACAD,EACA,CACA,MAAMlD,EAAI,KAAK,kBAAkB8C,CAAU,EACrCM,EAAQN,EAAa,KAAK,cAAc9C,CAAC,EACzC6C,EAAS,KAAK,UAAU7C,CAAC,EACzB+C,EAAWC,EAAO,KAAK,YAAYhD,CAAC,EAAG,KAAK,QAAQ,EAE1D,IAAIwC,EAAcY,GAASnD,EAAI4C,EAAO,CAAC,GAAMC,EAAaC,EAAS,CAAC,EAChEN,EAAcW,GAASP,EAAO,CAAC,EAAI3C,GAAM4C,EAAaC,EAAS,CAAC,EAEpE,OAAII,GACFX,EAAaa,EAAKb,EAAYvB,CAAQ,EAAI,EAC1CwB,EAAaY,EAAKZ,EAAYxB,CAAQ,EAAI,IAE1CuB,EAAac,EAAMd,EAAYvB,CAAQ,EACvCwB,EAAaa,EAAMb,EAAYxB,CAAQ,GAGlCsC,EAAwBvD,EAAGwC,EAAYC,EAAYS,CAAa,CACxE,CAiBD,uBAAuBjD,EAAGC,EAAGF,EAAGmD,EAA2BD,EAAe,CACxE,MAAML,EAAS,KAAK,UAAU7C,CAAC,EACzB8C,EAAa,KAAK,cAAc9C,CAAC,EACjC+C,EAAWC,EAAO,KAAK,YAAYhD,CAAC,EAAG,KAAK,QAAQ,EAE1D,IAAIwC,GAAcvC,EAAI4C,EAAO,CAAC,GAAKC,EAAaC,EAAS,CAAC,EACtDN,GAAcI,EAAO,CAAC,EAAI3C,GAAK4C,EAAaC,EAAS,CAAC,EAE1D,OAAII,GACFX,EAAaa,EAAKb,EAAYvB,CAAQ,EAAI,EAC1CwB,EAAaY,EAAKZ,EAAYxB,CAAQ,EAAI,IAE1CuB,EAAac,EAAMd,EAAYvB,CAAQ,EACvCwB,EAAaa,EAAMb,EAAYxB,CAAQ,GAGlCsC,EAAwBvD,EAAGwC,EAAYC,EAAYS,CAAa,CACxE,CAUD,yBAAyBD,EAAYjD,EAAGkD,EAAe,CACrD,OAAO,KAAK,uBACVD,EAAW,CAAC,EACZA,EAAW,CAAC,EACZjD,EACA,GACAkD,CACN,CACG,CAMD,uBAAuB/C,EAAW,CAChC,OAAO,KAAK,aAAaA,EAAU,CAAC,CAAC,CACtC,CAUD,YAAYH,EAAG,CACb,OAAI,KAAK,UACA,KAAK,UAEL,KAAK,WAAWA,CAAC,CAE3B,CAMD,iBAAiBA,EAAG,CAClB,OAAK,KAAK,gBAKD,KAAK,gBAAgBA,CAAC,EAJtB,KAAK,QACR,KAAK,0BAA0B,KAAK,QAASA,CAAC,EAC9C,IAIP,CAmBD,kBAAkB8C,EAAYU,EAAe,CAC3C,MAAMxD,EAAIyD,EACR,KAAK,aACLX,EACAU,GAAiB,CACvB,EACI,OAAOE,GAAM1D,EAAG,KAAK,QAAS,KAAK,OAAO,CAC3C,CAQD,4BAA4BG,EAAWwD,EAAU,CAC/C,OAAOC,GACLD,EACA,EACAA,EAAS,OACT,EACA,KAAK,mBAAmBxD,CAAS,CACvC,CACG,CAMD,qBAAqBqB,EAAQ,CAC3B,MAAMqC,EAAS,KAAK,aAAa,OAC3BC,EAAiB,IAAI,MAAMD,CAAM,EACvC,QAAS7D,EAAI,KAAK,QAASA,EAAI6D,EAAQ,EAAE7D,EACvC8D,EAAe9D,CAAC,EAAI,KAAK,0BAA0BwB,EAAQxB,CAAC,EAE9D,KAAK,gBAAkB8D,CACxB,CACH,CAEA,MAAAC,EAAe7C,GC7pBR,SAAS8C,EAAiBC,EAAY,CAC3C,IAAIxD,EAAWwD,EAAW,qBAC1B,OAAKxD,IACHA,EAAWyD,GAAoBD,CAAU,EACzCA,EAAW,mBAAmBxD,CAAQ,GAEjCA,CACT,CAQO,SAAS0D,GAAM1D,EAAUN,EAAW8D,EAAY,CACrD,MAAMjE,EAAIG,EAAU,CAAC,EACfiE,EAAS3D,EAAS,mBAAmBN,CAAS,EAC9CkE,EAAmBC,EAAqBL,CAAU,EACxD,GAAKM,GAAmBF,EAAkBD,CAAM,EAQ9C,OAAOjE,EAR0C,CACjD,MAAMqE,EAAaC,EAASJ,CAAgB,EACtCK,EAAa,KAAK,MACrBL,EAAiB,CAAC,EAAID,EAAO,CAAC,GAAKI,CAC1C,EACI,OAAAJ,EAAO,CAAC,GAAKI,EAAaE,EACnBjE,EAAS,yBAAyB2D,EAAQpE,CAAC,CACtD,CAGA,CAWO,SAAS2E,GAAgBnD,EAAQoD,EAAS7B,EAAU8B,EAAQ,CACjEA,EAASA,IAAW,OAAYA,EAAS,WAEzC,MAAMC,EAAcC,EAAsBvD,EAAQoD,EAAS7B,CAAQ,EAEnE,OAAO,IAAI7B,EAAS,CAClB,OAAQM,EACR,OAAQwD,GAAUxD,EAAQqD,CAAM,EAChC,YAAaC,EACb,SAAU/B,CACd,CAAG,CACH,CAoBO,SAASkC,GAAU1F,EAAS,CACjC,MAAM2F,EAAa3F,GAAW,GAExBiC,EAAS0D,EAAW,QAAUC,EAAc,WAAW,EAAE,YAEzDC,EAAc,CAClB,OAAQ5D,EACR,QAAS0D,EAAW,QACpB,SAAUA,EAAW,SACrB,YAAaH,EACXvD,EACA0D,EAAW,QACXA,EAAW,SACXA,EAAW,aACZ,CACL,EACE,OAAO,IAAIhE,EAASkE,CAAW,CACjC,CAYA,SAASL,EAAsBvD,EAAQoD,EAAS7B,EAAUsC,EAAe,CACvET,EAAUA,IAAY,OAAYA,EAAUU,GAC5CvC,EAAWC,EAAOD,IAAa,OAAYA,EAAWrB,CAAiB,EAEvE,MAAM6D,EAASC,GAAUhE,CAAM,EACzBiE,EAAQhB,EAASjD,CAAM,EAE7B6D,EACEA,EAAgB,EACZA,EACA,KAAK,IAAII,EAAQ1C,EAAS,CAAC,EAAGwC,EAASxC,EAAS,CAAC,CAAC,EAExD,MAAMc,EAASe,EAAU,EACnBE,EAAc,IAAI,MAAMjB,CAAM,EACpC,QAAS7D,EAAI,EAAGA,EAAI6D,EAAQ,EAAE7D,EAC5B8E,EAAY9E,CAAC,EAAIqF,EAAgB,KAAK,IAAI,EAAGrF,CAAC,EAEhD,OAAO8E,CACT,CAWO,SAASZ,GAAoBD,EAAYW,EAAS7B,EAAU8B,EAAQ,CACzE,MAAMrD,EAAS8C,EAAqBL,CAAU,EAC9C,OAAOU,GAAgBnD,EAAQoD,EAAS7B,EAAU8B,CAAM,CAC1D,CAQO,SAASP,EAAqBL,EAAY,CAC/CA,EAAakB,EAAclB,CAAU,EACrC,IAAIzC,EAASyC,EAAW,YACxB,GAAI,CAACzC,EAAQ,CACX,MAAMkE,EACH,IAAMC,GAAgB,QAAW1B,EAAW,iBAAgB,EAC/DzC,EAASzB,EAAe,CAAC2F,EAAM,CAACA,EAAMA,EAAMA,CAAI,CACjD,CACD,OAAOlE,CACT,CCrHA,MAAMoE,WAAmBC,EAAO,CAI9B,YAAYtG,EAAS,CACnB,MAAM,CACJ,aAAcA,EAAQ,aACtB,wBAAyBA,EAAQ,wBACjC,WAAYA,EAAQ,WACpB,MAAOA,EAAQ,MACf,MAAOA,EAAQ,MACf,YAAaA,EAAQ,WAC3B,CAAK,EAKD,KAAK,GAKL,KAAK,KAKL,KAAK,GAML,KAAK,QAAUA,EAAQ,SAAW,OAAYA,EAAQ,OAAS,GAM/D,KAAK,gBACHA,EAAQ,iBAAmB,OAAYA,EAAQ,eAAiB,EAKlE,KAAK,SAAWA,EAAQ,WAAa,OAAYA,EAAQ,SAAW,KAEpE,MAAMwD,EAAW,CAAC,IAAK,GAAG,EACtB,KAAK,UACPC,EAAO,KAAK,SAAS,YAAY,KAAK,SAAS,WAAU,CAAE,EAAGD,CAAQ,EAOxE,KAAK,UAAY,IAAIpC,EAAUpB,EAAQ,WAAa,CAAC,EAMrD,KAAK,QAAU,CAAC,EAAG,CAAC,EAMpB,KAAK,KAAOA,EAAQ,KAAO,GAM3B,KAAK,YAAc,CACjB,WAAYA,EAAQ,WACpB,YAAaA,EAAQ,WAC3B,EASI,KAAK,WAAaA,EAAQ,WAAaA,EAAQ,WAAa,CAC7D,CAKD,gBAAiB,CACf,OAAO,KAAK,UAAU,gBACvB,CAMD,YAAY0E,EAAYrD,EAAW,CACjC,MAAMkF,EAAY,KAAK,0BAA0B7B,CAAU,EACvD6B,GACFA,EAAU,YAAYlF,CAAS,CAElC,CAWD,kBAAkBqD,EAAYjE,EAAGU,EAAWoB,EAAU,CACpD,MAAMgE,EAAY,KAAK,0BAA0B7B,CAAU,EAC3D,GAAI,CAAC6B,EACH,MAAO,GAGT,IAAIC,EAAU,GACVlF,EAAMmF,EAAcC,EACxB,QAAShG,EAAIS,EAAU,KAAMT,GAAKS,EAAU,KAAM,EAAET,EAClD,QAASC,EAAIQ,EAAU,KAAMR,GAAKQ,EAAU,KAAM,EAAER,EAClD8F,EAAe5F,EAAUJ,EAAGC,EAAGC,CAAC,EAChC+F,EAAS,GACLH,EAAU,YAAYE,CAAY,IACpCnF,EACEiF,EAAU,IAAIE,CAAY,EAE5BC,EAASpF,EAAK,aAAeqF,EAAU,OACnCD,IACFA,EAASnE,EAASjB,CAAI,IAAM,KAG3BoF,IACHF,EAAU,IAIhB,OAAOA,CACR,CAMD,uBAAuB9B,EAAY,CACjC,MAAO,EACR,CAMD,QAAS,CACP,OAAO,KAAK,IACb,CAOD,OAAO7E,EAAK,CACN,KAAK,OAASA,IAChB,KAAK,KAAOA,EACZ,KAAK,QAAO,EAEf,CAMD,UAAU6E,EAAY,CACpB,OAAO,KAAK,OACb,CAKD,gBAAiB,CACf,OAAK,KAAK,SAGH,KAAK,SAAS,iBAFZ,IAGV,CAWD,QAAQjE,EAAGC,EAAGC,EAAGiG,EAAYlC,EAAY,CACvC,OAAOmC,GAAQ,CAChB,CAOD,aAAc,CACZ,OAAO,KAAK,QACb,CAMD,yBAAyBnC,EAAY,CACnC,OAAK,KAAK,SAGD,KAAK,SAFLoC,EAAyBpC,CAAU,CAI7C,CAOD,0BAA0BA,EAAY,CACpC,MAAMqC,EAAmB,KAAK,gBAC9B,OAAA9G,EACE8G,IAAqB,MAAQC,EAAWD,EAAkBrC,CAAU,EACpE,EACN,EACW,KAAK,SACb,CASD,kBAAkBkC,EAAY,CAC5B,OAAO,KAAK,eACb,CAQD,iBAAiBnG,EAAGmG,EAAYlC,EAAY,CAC1C,MAAMxD,EAAW,KAAK,yBAAyBwD,CAAU,EACnDuC,EAAiB,KAAK,kBAAkBL,CAAU,EAClDpD,EAAWC,EAAOvC,EAAS,YAAYT,CAAC,EAAG,KAAK,OAAO,EAC7D,OAAIwG,GAAkB,EACbzD,EAEA0D,GAAU1D,EAAUyD,EAAgB,KAAK,OAAO,CAE1D,CAWD,+BAA+BrG,EAAW8D,EAAY,CACpDA,EAAaA,IAAe,OAAYA,EAAa,KAAK,cAAa,EACvE,MAAMxD,EAAW,KAAK,yBAAyBwD,CAAU,EACzD,OAAI,KAAK,SAAQ,GAAMA,EAAW,SAAQ,IACxC9D,EAAYgE,GAAM1D,EAAUN,EAAW8D,CAAU,GAE5CzD,GAAiBL,EAAWM,CAAQ,EAAIN,EAAY,IAC5D,CAMD,OAAQ,CACN,KAAK,UAAU,OAChB,CAED,SAAU,CACR,KAAK,MAAK,EACV,MAAM,QAAO,CACd,CAOD,gBAAgBuG,EAAWzC,EAAY,CACrC,MAAM6B,EAAY,KAAK,0BAA0B7B,CAAU,EACvDyC,EAAYZ,EAAU,gBACxBA,EAAU,cAAgBY,EAE7B,CAUD,QAAQ1G,EAAGC,EAAGC,EAAG+D,EAAY,CAAE,CACjC,CAOO,MAAM0C,WAAwBC,EAAM,CAKzC,YAAYC,EAAMhG,EAAM,CACtB,MAAMgG,CAAI,EAOV,KAAK,KAAOhG,CACb,CACH,CAEA,MAAAiG,GAAelB,GC/XR,SAASmB,GAAmBC,EAAUvG,EAAU,CACrD,MAAMwG,EAAS,SACTC,EAAS,SACTC,EAAS,SACTC,EAAa,UACnB,OAOE,SAAUjH,EAAWgG,EAAYlC,EAAY,CAC3C,GAAK9D,EAGH,OAAO6G,EACJ,QAAQC,EAAQ9G,EAAU,CAAC,EAAE,SAAQ,CAAE,EACvC,QAAQ+G,EAAQ/G,EAAU,CAAC,EAAE,SAAQ,CAAE,EACvC,QAAQgH,EAAQhH,EAAU,CAAC,EAAE,SAAQ,CAAE,EACvC,QAAQiH,EAAY,UAAY,CAC/B,MAAMpH,EAAIG,EAAU,CAAC,EACfkH,EAAQ5G,EAAS,iBAAiBT,CAAC,EACzC,OAAAR,EAAO6H,EAAO,EAAE,GACNA,EAAM,UAAS,EAAKlH,EAAU,CAAC,EAAI,GACpC,UACrB,CAAW,CAEN,CAEL,CAOO,SAASmH,GAAoBC,EAAW9G,EAAU,CACvD,MAAM+G,EAAMD,EAAU,OAChBE,EAAmB,IAAI,MAAMD,CAAG,EACtC,QAAS9H,EAAI,EAAGA,EAAI8H,EAAK,EAAE9H,EACzB+H,EAAiB/H,CAAC,EAAIqH,GAAmBQ,EAAU7H,CAAC,EAAGe,CAAQ,EAEjE,OAAOiH,GAA2BD,CAAgB,CACpD,CAMO,SAASC,GAA2BD,EAAkB,CAC3D,OAAIA,EAAiB,SAAW,EACvBA,EAAiB,CAAC,EASzB,SAAUtH,EAAWgG,EAAYlC,EAAY,CAC3C,GAAK9D,EAEE,CACL,MAAMwH,EAAIC,GAAczH,CAAS,EAC3B0H,EAAQC,GAAOH,EAAGF,EAAiB,MAAM,EAC/C,OAAOA,EAAiBI,CAAK,EAAE1H,EAAWgG,EAAYlC,CAAU,CACjE,KALC,OAMH,CAEL,CAgBO,SAAS8D,GAAUC,EAAK,CAC7B,MAAMC,EAAO,CAAA,EACb,IAAIC,EAAQ,sBAAsB,KAAKF,CAAG,EAC1C,GAAIE,EAAO,CAET,MAAMC,EAAgBD,EAAM,CAAC,EAAE,WAAW,CAAC,EACrCE,EAAeF,EAAM,CAAC,EAAE,WAAW,CAAC,EAC1C,IAAIG,EACJ,IAAKA,EAAWF,EAAeE,GAAYD,EAAc,EAAEC,EACzDJ,EAAK,KAAKD,EAAI,QAAQE,EAAM,CAAC,EAAG,OAAO,aAAaG,CAAQ,CAAC,CAAC,EAEhE,OAAOJ,CACR,CAED,GADAC,EAAQ,kBAAkB,KAAKF,CAAG,EAC9BE,EAAO,CAET,MAAMI,EAAO,SAASJ,EAAM,CAAC,EAAG,EAAE,EAClC,QAASxI,EAAI,SAASwI,EAAM,CAAC,EAAG,EAAE,EAAGxI,GAAK4I,EAAM5I,IAC9CuI,EAAK,KAAKD,EAAI,QAAQE,EAAM,CAAC,EAAGxI,EAAE,SAAU,CAAA,CAAC,EAE/C,OAAOuI,CACR,CACD,OAAAA,EAAK,KAAKD,CAAG,EACNC,CACT,CCrFA,MAAMM,UAAgB3C,EAAW,CAI/B,YAAYrG,EAAS,CACnB,MAAM,CACJ,aAAcA,EAAQ,aACtB,UAAWA,EAAQ,UACnB,OAAQA,EAAQ,OAChB,WAAYA,EAAQ,WACpB,MAAOA,EAAQ,MACf,SAAUA,EAAQ,SAClB,eAAgBA,EAAQ,eACxB,MAAOA,EAAQ,MACf,WAAYA,EAAQ,WACpB,YAAaA,EAAQ,YACrB,IAAKA,EAAQ,IACb,wBAAyBA,EAAQ,wBACjC,WAAYA,EAAQ,UAC1B,CAAK,EAMD,KAAK,yBACH,KAAK,kBAAoBgJ,EAAQ,UAAU,gBAM7C,KAAK,iBAAmBhJ,EAAQ,iBAE5BA,EAAQ,kBACV,KAAK,gBAAkBA,EAAQ,iBAOjC,KAAK,KAAO,KAERA,EAAQ,KACV,KAAK,QAAQA,EAAQ,IAAI,EAChBA,EAAQ,KACjB,KAAK,OAAOA,EAAQ,GAAG,EAOzB,KAAK,iBAAmB,EACzB,CAOD,qBAAsB,CACpB,OAAO,KAAK,gBACb,CAOD,oBAAqB,CACnB,OAAO,OAAO,eAAe,IAAI,EAAE,kBAAoB,KAAK,gBACxD,KAAK,gBAAgB,KAAK,IAAI,EAC9B,KAAK,eACV,CASD,SAAU,CACR,OAAO,KAAK,IACb,CAOD,iBAAiBiJ,EAAO,CACtB,MAAM3H,EAAoD2H,EAAM,OAC1DC,EAAMC,EAAO7H,CAAI,EACjB8H,EAAY9H,EAAK,WACvB,IAAIgG,EACA8B,GAAazC,EAAU,SACzB,KAAK,iBAAiBuC,CAAG,EAAI,GAC7B5B,EAAO9F,EAAc,eACZ0H,KAAO,KAAK,mBACrB,OAAO,KAAK,iBAAiBA,CAAG,EAChC5B,EACE8B,GAAazC,EAAU,MACnBnF,EAAc,cACd4H,GAAazC,EAAU,OACvBnF,EAAc,YACd,QAEJ8F,GAAQ,MACV,KAAK,cAAc,IAAIF,GAAgBE,EAAMhG,CAAI,CAAC,CAErD,CAOD,oBAAoB+H,EAAkB,CACpC,KAAK,UAAU,QACf,KAAK,iBAAmBA,EACxB,KAAK,QAAO,CACb,CAQD,mBAAmBC,EAAiBzJ,EAAK,CACvC,KAAK,gBAAkByJ,EACvB,KAAK,UAAU,qBACX,OAAOzJ,EAAQ,IACjB,KAAK,OAAOA,CAAG,EAEf,KAAK,QAAO,CAEf,CAOD,OAAO4I,EAAK,CACV,MAAMC,EAAOF,GAAUC,CAAG,EAC1B,KAAK,KAAOC,EACZ,KAAK,QAAQA,CAAI,CAClB,CAOD,QAAQA,EAAM,CACZ,KAAK,KAAOA,EACZ,MAAM7I,EAAM6I,EAAK,KAAK;AAAA,CAAI,EACtB,KAAK,yBACP,KAAK,mBAAmBX,GAAoBW,EAAM,KAAK,QAAQ,EAAG7I,CAAG,EAErE,KAAK,OAAOA,CAAG,CAElB,CAQD,gBAAgBe,EAAWgG,EAAYlC,EAAY,CAElD,CAQD,QAAQjE,EAAGC,EAAGC,EAAG,CACf,MAAM8F,EAAe5F,EAAUJ,EAAGC,EAAGC,CAAC,EAClC,KAAK,UAAU,YAAY8F,CAAY,GACzC,KAAK,UAAU,IAAIA,CAAY,CAElC,CACH,CAEA,MAAA8C,GAAeP,ECpKf,MAAMQ,WAAkBR,EAAQ,CAI9B,YAAYhJ,EAAS,CACnB,MAAM,CACJ,aAAcA,EAAQ,aACtB,UAAWA,EAAQ,UACnB,OAAQA,EAAQ,OAChB,WAAYA,EAAQ,WACpB,MAAOA,EAAQ,MACf,SAAUA,EAAQ,SAClB,iBAAkBA,EAAQ,iBACtBA,EAAQ,iBACRyJ,GACJ,eAAgBzJ,EAAQ,eACxB,gBAAiBA,EAAQ,gBACzB,IAAKA,EAAQ,IACb,KAAMA,EAAQ,KACd,MAAOA,EAAQ,MACf,WAAYA,EAAQ,WACpB,YACEA,EAAQ,cAAgB,OAAYA,EAAQ,YAAc,GAC5D,IAAKA,EAAQ,IACb,wBAAyBA,EAAQ,wBACjC,WAAYA,EAAQ,UAC1B,CAAK,EAMD,KAAK,YACHA,EAAQ,cAAgB,OAAYA,EAAQ,YAAc,KAM5D,KAAK,UACHA,EAAQ,YAAc,OAAYA,EAAQ,UAAY0J,GAMxD,KAAK,uBAAyB,GAM9B,KAAK,sBAAwB,GAM7B,KAAK,4BAA8B1J,EAAQ,2BAM3C,KAAK,yBAA2B,EACjC,CAKD,gBAAiB,CACf,GAAI,KAAK,UAAU,iBACjB,MAAO,GAEP,UAAWH,KAAO,KAAK,uBACrB,GAAI,KAAK,uBAAuBA,CAAG,EAAE,eAAc,EACjD,MAAO,GAIb,MAAO,EACR,CAMD,YAAY6E,EAAYrD,EAAW,CACjC,MAAMsI,EAAgB,KAAK,0BAA0BjF,CAAU,EAE/D,KAAK,UAAU,YACb,KAAK,WAAaiF,EAAgBtI,EAAY,CAAE,CACtD,EACI,UAAWuI,KAAM,KAAK,uBAAwB,CAC5C,MAAMrD,EAAY,KAAK,uBAAuBqD,CAAE,EAChDrD,EAAU,YAAYA,GAAaoD,EAAgBtI,EAAY,CAAE,CAAA,CAClE,CACF,CAMD,uBAAuBqD,EAAY,CACjC,OACE,KAAK,cAAe,GACpBA,GACA,CAACsC,EAAW,KAAK,cAAa,EAAItC,CAAU,EAErC,EAEA,KAAK,WAEf,CAKD,WAAY,CACV,MAAO,EACR,CAMD,QAAS,CACP,IAAI7E,EAAM,MAAM,SAChB,OAAK,KAAK,mBACRA,GAAO,0BAEFA,CACR,CAMD,UAAU6E,EAAY,CACpB,OACE,KAAK,cAAe,GACpBA,GACA,CAACsC,EAAW,KAAK,cAAa,EAAItC,CAAU,EAErC,GAEA,MAAM,UAAUA,CAAU,CAEpC,CAMD,yBAAyBA,EAAY,CACnC,MAAMmF,EAAW,KAAK,gBACtB,GAAI,KAAK,WAAa,CAACA,GAAY7C,EAAW6C,EAAUnF,CAAU,GAChE,OAAO,KAAK,SACP,CACL,MAAMoF,EAAUX,EAAOzE,CAAU,EACjC,OAAMoF,KAAW,KAAK,wBACpB,KAAK,sBAAsBA,CAAO,EAChChD,EAAyBpC,CAAU,GAEhC,KAAK,sBAAsBoF,CAAO,CAC1C,CACF,CAMD,0BAA0BpF,EAAY,CACpC,MAAMmF,EAAW,KAAK,gBACtB,GAAI,CAACA,GAAY7C,EAAW6C,EAAUnF,CAAU,EAC9C,OAAO,KAAK,UACP,CACL,MAAMoF,EAAUX,EAAOzE,CAAU,EACjC,OAAMoF,KAAW,KAAK,yBACpB,KAAK,uBAAuBA,CAAO,EAAI,IAAI1I,EACzC,KAAK,UAAU,aACzB,GAEa,KAAK,uBAAuB0I,CAAO,CAC3C,CACF,CAYD,YAAYrJ,EAAGC,EAAGC,EAAGiG,EAAYlC,EAAY7E,EAAK,CAChD,MAAMe,EAAY,CAACH,EAAGC,EAAGC,CAAC,EACpBoJ,EAAe,KAAK,+BACxBnJ,EACA8D,CACN,EACUsF,EAAUD,EACZ,KAAK,gBAAgBA,EAAcnD,EAAYlC,CAAU,EACzD,OACEpD,EAAO,IAAI,KAAK,UACpBV,EACAoJ,IAAY,OAAYrD,EAAU,KAAOA,EAAU,MACnDqD,IAAY,OAAYA,EAAU,GAClC,KAAK,YACL,KAAK,iBACL,KAAK,WACX,EACI,OAAA1I,EAAK,IAAMzB,EACXyB,EAAK,iBAAiB2I,GAAU,OAAQ,KAAK,iBAAiB,KAAK,IAAI,CAAC,EACjE3I,CACR,CAUD,QAAQb,EAAGC,EAAGC,EAAGiG,EAAYlC,EAAY,CACvC,MAAMqC,EAAmB,KAAK,gBAC9B,GACE,CAACA,GACD,CAACrC,GACDsC,EAAWD,EAAkBrC,CAAU,EAEvC,OAAO,KAAK,gBACVjE,EACAC,EACAC,EACAiG,EACAG,GAAoBrC,CAC5B,EACW,CACL,MAAMwF,EAAQ,KAAK,0BAA0BxF,CAAU,EACjD9D,EAAY,CAACH,EAAGC,EAAGC,CAAC,EAC1B,IAAIW,EACJ,MAAMmF,EAAe3F,EAAOF,CAAS,EACjCsJ,EAAM,YAAYzD,CAAY,IAChCnF,EAAO4I,EAAM,IAAIzD,CAAY,GAE/B,MAAM5G,EAAM,KAAK,SACjB,GAAIyB,GAAQA,EAAK,KAAOzB,EACtB,OAAOyB,EACF,CACL,MAAM6I,EAAiB,KAAK,yBAAyBpD,CAAgB,EAC/DqD,EAAiB,KAAK,yBAAyB1F,CAAU,EACzD2F,EAAmB,KAAK,+BAC5BzJ,EACA8D,CACV,EACc4F,EAAU,IAAIC,GAClBxD,EACAoD,EACAzF,EACA0F,EACAxJ,EACAyJ,EACA,KAAK,kBAAkBzD,CAAU,EACjC,KAAK,UAAW,EAChB,SAAUnG,EAAGC,EAAGC,EAAGiG,EAAY,CAC7B,OAAO,KAAK,gBAAgBnG,EAAGC,EAAGC,EAAGiG,EAAYG,CAAgB,CAC7E,EAAY,KAAK,IAAI,EACX,KAAK,4BACL,KAAK,yBACL,KAAK,eAAgB,CAC/B,EACQ,OAAAuD,EAAQ,IAAMzK,EAEVyB,GACFgJ,EAAQ,YAAchJ,EACtBgJ,EAAQ,oBAAmB,EAC3BJ,EAAM,QAAQzD,EAAc6D,CAAO,GAEnCJ,EAAM,IAAIzD,EAAc6D,CAAO,EAE1BA,CACR,CACF,CACF,CAWD,gBAAgB7J,EAAGC,EAAGC,EAAGiG,EAAYlC,EAAY,CAC/C,IAAIpD,EAAO,KACX,MAAMmF,EAAe5F,EAAUJ,EAAGC,EAAGC,CAAC,EAChCd,EAAM,KAAK,SACjB,GAAI,CAAC,KAAK,UAAU,YAAY4G,CAAY,EAC1CnF,EAAO,KAAK,YAAYb,EAAGC,EAAGC,EAAGiG,EAAYlC,EAAY7E,CAAG,EAC5D,KAAK,UAAU,IAAI4G,EAAcnF,CAAI,UAErCA,EAAO,KAAK,UAAU,IAAImF,CAAY,EAClCnF,EAAK,KAAOzB,EAAK,CAInB,MAAM2K,EAAclJ,EACpBA,EAAO,KAAK,YAAYb,EAAGC,EAAGC,EAAGiG,EAAYlC,EAAY7E,CAAG,EAGxD2K,EAAY,YAAc7D,EAAU,KAEtCrF,EAAK,YAAckJ,EAAY,YAE/BlJ,EAAK,YAAckJ,EAErBlJ,EAAK,oBAAmB,EACxB,KAAK,UAAU,QAAQmF,EAAcnF,CAAI,CAC1C,CAEH,OAAOA,CACR,CAOD,2BAA2BmJ,EAAQ,CACjC,GAAI,KAAK,0BAA4BA,EAGrC,MAAK,yBAA2BA,EAChC,UAAWb,KAAM,KAAK,uBACpB,KAAK,uBAAuBA,CAAE,EAAE,MAAK,EAEvC,KAAK,QAAO,EACb,CAcD,yBAAyBlF,EAAYgG,EAAU,CAC7C,MAAMC,EAAO/E,EAAclB,CAAU,EACrC,GAAIiG,EAAM,CACR,MAAMb,EAAUX,EAAOwB,CAAI,EACrBb,KAAW,KAAK,wBACpB,KAAK,sBAAsBA,CAAO,EAAIY,EAEzC,CACF,CAED,OAAQ,CACN,MAAM,MAAK,EACX,UAAWd,KAAM,KAAK,uBACpB,KAAK,uBAAuBA,CAAE,EAAE,MAAK,CAExC,CACH,CAMA,SAASH,GAAwBmB,EAAWC,EAAK,CACGD,EAAU,SAAQ,EAAI,IACtEC,CACJ,CAEA,MAAAC,GAAetB,GCzXf,MAAMuB,WAAYvB,EAAU,CAI1B,YAAYxJ,EAAS,CACnBA,EAAUA,GAAW,GAErB,MAAM0E,EACJ1E,EAAQ,aAAe,OAAYA,EAAQ,WAAa,YAEpDkB,EACJlB,EAAQ,WAAa,OACjBA,EAAQ,SACR0F,GAAU,CACR,OAAQX,EAAqBL,CAAU,EACvC,cAAe1E,EAAQ,cACvB,QAASA,EAAQ,QACjB,QAASA,EAAQ,QACjB,SAAUA,EAAQ,QAC9B,CAAW,EAEP,MAAM,CACJ,aAAcA,EAAQ,aACtB,UAAWA,EAAQ,UACnB,YAAaA,EAAQ,YACrB,YAAaA,EAAQ,YACrB,OAAQA,EAAQ,OAChB,WAAY0E,EACZ,2BAA4B1E,EAAQ,2BACpC,SAAUkB,EACV,iBAAkBlB,EAAQ,iBAC1B,eAAgBA,EAAQ,eACxB,gBAAiBA,EAAQ,gBACzB,IAAKA,EAAQ,IACb,KAAMA,EAAQ,KACd,MAAOA,EAAQ,QAAU,OAAYA,EAAQ,MAAQ,GACrD,WAAYA,EAAQ,WACpB,wBAAyBA,EAAQ,wBACjC,WAAYA,EAAQ,UAC1B,CAAK,EAMD,KAAK,QAAUA,EAAQ,SAAW,OAAYA,EAAQ,OAAS,CAChE,CAKD,WAAY,CACV,OAAO,KAAK,OACb,CACH,CAEA,MAAAgL,GAAeD,GCnHFE,GACX,2GAsCF,MAAMC,WAAYH,EAAI,CAIpB,YAAY/K,EAAS,CACnBA,EAAUA,GAAW,GAErB,IAAImL,EACAnL,EAAQ,eAAiB,OAC3BmL,EAAenL,EAAQ,aAEvBmL,EAAe,CAACF,EAAW,EAG7B,MAAMG,EACJpL,EAAQ,cAAgB,OAAYA,EAAQ,YAAc,YAEtDyI,EACJzI,EAAQ,MAAQ,OACZA,EAAQ,IACR,iDAEN,MAAM,CACJ,aAAcmL,EACd,wBAAyB,GACzB,UAAWnL,EAAQ,UACnB,YAAaoL,EACb,YAAapL,EAAQ,YACrB,QAASA,EAAQ,UAAY,OAAYA,EAAQ,QAAU,GAC3D,OAAQA,EAAQ,SAAW,OAAYA,EAAQ,OAAS,GACxD,2BAA4BA,EAAQ,2BACpC,iBAAkBA,EAAQ,iBAC1B,WAAYA,EAAQ,WACpB,IAAKyI,EACL,MAAOzI,EAAQ,MACf,WAAYA,EAAQ,UAC1B,CAAK,CACF,CACH,CAEA,MAAAqL,GAAeH,GCjFf,IAAII,EAEG,SAASC,IAAe,CAE3BC,EAAa,UAAW,EAAC,MAAO,CACpC,CAEA,SAASC,GAAcC,EAASnI,EAAY,CACxC,IAAIoI,EAEJ,OAAID,EAAQ,YAAW,EAAG,QAAO,IAAO,aACpCC,EAAO,IAAIC,EAAK,CAEZ,KAAM,iBACN,KAAM,IAAIC,EAAK,CAAE,MAAO,MAAM,CAAE,EAChC,OAAQ,IAAIC,EAAO,CAAE,MAAO,OAAQ,MAAO,EAAG,EAC9C,QAAS,EACT,QAAS,IACT,UAAW,SACX,aAAc,QAC1B,CAAS,EAEDH,EAAO,IAAIC,EAAK,CACZ,KAAMF,EAAQ,IAAI,OAAO,EAAE,SAAU,EACrC,KAAM,iBAGN,QAAS,EACT,QAAS,EACT,UAAW,SACX,aAAc,QAC1B,CAAS,EAGE,IAAIK,EAAM,CAEb,OAAQ,IAAID,EAAO,CACf,MAAO,UACP,MAAO,CACnB,CAAS,EAED,KAAAH,EAEA,MAAO,IAAIK,GAAO,CACd,OAAQ,GACR,KAAM,IAAIH,EAAK,CACX,MAAO,SACvB,CAAa,CACb,CAAS,CACT,CAAK,CACL,CAEA,MAAML,EAAe,IAAIS,GAAY,CACjC,OAAQ,IAAIC,GACZ,MAAOT,EACX,CAAC,EAED,SAASU,IAAyB,CAG9BX,EAAa,UAAS,EAAG,eAAe,SAAUE,EAAS,CACnDA,EAAQ,YAAW,EAAG,QAAO,IAAO,cAEpCF,EAAa,UAAS,EAAG,cAAcE,CAAO,CAE1D,CAAK,CACL,CAEA,SAASU,GAAkBC,EAAKC,EAAOC,EAAa,CAChD,IAAItK,EAASuK,GAAe,CAACF,CAAK,CAAC,EACnC,MAAMG,EAAiBJ,EAAI,QAAO,EAAG,cAAe,EAAG,EAKvD,OAJApK,EAASyK,GAAOzK,EAAQwK,CAAc,EAExBF,EAAY,UAAS,EAAG,oBAAoBtK,CAAM,EAEtD,OAAS,CAKvB,CAEA,SAAS0K,GAAiBC,EAAM,CAG5B,GAAI,OAAO,KAAKA,CAAI,EAAE,SAAW,EAAG,CAChCT,GAAuB,EAEvB,MAAMU,EADgB,IAAIC,EAAS,EACP,aAAaF,CAAI,EAC7CpB,EAAa,UAAS,EAAG,YAAYqB,CAAK,EAE1CE,GAAYF,EAAOvB,EAAmBE,CAAY,CACrD,CACL,CAEA,SAASwB,GAASC,EAAKC,EAAc1B,EAAc,CAC/C,MAAME,EAAUuB,EAAI,QACdvJ,EAAagI,EAAQ,YAAW,EAAG,eAAgB,EACnDyB,EAAwBD,EAAa,UAAS,EAAG,8BAA8BxJ,CAAU,EAE/F,GAAIyJ,EAAuB,CACvB,MAAM7E,EAAQ8E,EAAgB,EAAG,OAE3BC,EAASF,EAAsB,MAAO,EAC5C,OAAAzB,EAAQ,IAAI,SAAU2B,CAAM,EAC5B3B,EAAQ,IAAI,QAASpD,CAAK,EACnB,EACV,CAED,MAAO,EACX,CAEA,SAAS8E,GAAoB,CACzB,MAAME,EAAgB,CAAE,EAExB,OAAA9B,EAAa,UAAS,EAAG,eAErB,SAAUE,EAAS,CACXA,EAAQ,YAAW,EAAG,QAAO,IAAO,SACpC4B,EAAc,KAAK5B,CAAO,CAEjC,CACJ,EAEM4B,CACX,CAEA,SAASC,GAAU/B,EAAc,CAC7B,MAAM8B,EAAgBF,EAAkB,EAExC,GAAIE,EAAc,QAAU,EAAG,CAC3B,MAAME,EAAgB,IAAIV,EAEpBW,EAAW,KAAK,UAAU,CAC5B,OAAQD,EAAc,cAAcF,CAAa,EACjD,MAAOI,GAAiB,CACpC,CAAS,EAEDC,GAAY,kCAAmCF,EAAUd,EAAe,CAC3E,CACL,CAEO,SAASiB,GAAmBvB,EAAKa,EAAc,CAClDb,EAAI,SAASb,CAAY,EAEzB,MAAMqC,EAAO,IAAIC,GAAK,CAClB,OAAQtC,EAAa,UAAW,EAChC,KAAM,QACN,UAAW,SAAUyB,EAAK,CACtB,OAAIc,GAAcd,CAAG,IAAM,GAChBb,GAAiBC,EAAKY,EAAI,WAAYC,CAAY,EAElD,EAEd,CACT,CAAK,EAED,OAAA1B,EAAa,UAAW,EAAC,GAAG,aAAc,SAAUyB,EAAK,CACjDA,EAAI,QAAQ,YAAa,EAAC,QAAO,IAAO,SACxCM,GAAqB,CAEjC,CAAK,EAEDjC,EAAoB,IAAI0C,GAAO,CAC3B,OAAQ,CAACxC,CAAY,EACrB,MAAO,SAAUE,EAASnI,EAAY,CAClC,OAAO,IAAIwI,EAAM,CACb,OAAQ,IAAID,EAAO,CACf,MAAO,UACP,MAAO,CAC3B,CAAiB,CACjB,CAAa,CACJ,CACT,CAAK,EACDR,EAAkB,UAAU,EAAK,EAEjCe,EAAI,eAAef,CAAiB,EAEpCuC,EAAK,GAAG,UAAW,SAAUZ,EAAK,CAC9BD,GAAQC,EAAKC,CAA0B,CAC/C,CAAK,EAEMW,CACX,CC9KA,SAASI,IAAQ,CAKb,MAAMC,EAAc,sBAEdC,EAAOC,GADE,CAAC,mBAAoB,mBAAoB,mBAAoB,iBAAiB,EACxD,YAAa,WAAW,EAEvDlB,EAAemB,GAAmBH,EADrB,KAC8C,0BAA0B,EAE3FI,GAAa,EAEb,MAAMjC,EAAM,IAAIkC,GAAI,CAChB,OAAQ,MACR,OAAQ,CACJ,IAAIC,GAAU,CACV,OAAQ,IAAItD,EAC5B,CAAa,EACDgC,CACH,EACD,KAAM,IAAIuB,GAAK,CACX,OAAQC,GAAUP,CAAI,EACtB,OAAQA,EACR,KAAM,EAClB,CAAS,CACT,CAAK,EAED,SAASQ,GAAgB,CACP,CAACC,EAAaC,CAAa,EACnC,QAAQ,SAAUC,EAAM,CAC1BA,EAAK,UAAU,EAAK,CAChC,CAAS,CACJ,CACD,MAAMC,EAAmB,CACrB,CACI,KAAM,mBACN,SAAUC,EACb,EACD,IACA,CACI,KAAM,wBACN,SAAU,UAAY,CAClBL,EAAc,EACdC,EAAY,UAAU,EAAI,CAC7B,CACJ,EACD,CACI,KAAM,eACN,SAAUrD,EACb,EACD,IACA,CACI,KAAM,0BACN,SAAU,UAAY,CAClBoD,EAAc,EACdE,EAAc,UAAU,EAAI,CAC/B,CACJ,EACD,CACI,KAAM,sBACN,SAAUI,EACb,EACD,GACH,EAEKC,EAAc,IAAIC,GAAY,CAChC,MAAO,IACP,aAAc,GACd,MAAOJ,CACf,CAAK,EACD1C,EAAI,WAAW6C,CAAW,EAE1B,MAAML,EAAgBO,GAAoB/C,EAAKa,CAAY,EACrD0B,EAAchB,GAAkBvB,EAAKa,CAAY,EAEvDb,EAAI,eAAeuC,CAAW,EAC9BvC,EAAI,eAAewC,CAAa,EAEhCF,EAAc,EACdC,EAAY,UAAU,EAAI,EAE1B,MAAMS,EAAO,IAAIC,GAAK,CAClB,OAAQpC,EAAa,UAAW,CACxC,CAAK,EAKDb,EAAI,eAAegD,CAAI,CAC3B,CAEApB,GAAI"}