{"version":3,"file":"OSM-f284ffe5.js","sources":["../../node_modules/ol/Tile.js","../../node_modules/ol/ImageTile.js","../../node_modules/ol/structs/LRUCache.js","../../node_modules/ol/tilecoord.js","../../node_modules/ol/TileRange.js","../../node_modules/ol/layer/TileProperty.js","../../node_modules/ol/layer/BaseTile.js","../../node_modules/ol/DataTile.js","../../node_modules/ol/reproj/common.js","../../node_modules/ol/reproj/Triangulation.js","../../node_modules/ol/reproj.js","../../node_modules/ol/reproj/DataTile.js","../../node_modules/ol/reproj/Tile.js","../../node_modules/ol/renderer/canvas/TileLayer.js","../../node_modules/ol/layer/Tile.js","../../node_modules/ol/source/TileEventType.js","../../node_modules/ol/tilegrid/TileGrid.js","../../node_modules/ol/tilegrid.js","../../node_modules/ol/source/Tile.js","../../node_modules/ol/uri.js","../../node_modules/ol/tileurlfunction.js","../../node_modules/ol/source/UrlTile.js","../../node_modules/ol/source/TileImage.js","../../node_modules/ol/source/XYZ.js","../../node_modules/ol/source/OSM.js"],"sourcesContent":["/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport {abstract} from './util.js';\nimport {easeIn} from './easing.js';\n\n/**\n * A function that takes a {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * A key assigned to the tile. This is used in conjunction with a source key\n     * to determine if a cached version of this tile may be used by the renderer.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @private\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    if (this.state === TileState.ERROR) {\n      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n      this.setState(TileState.EMPTY);\n    }\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.release();\n    super.disposeInternal();\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenImage} from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this),\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.unlistenImage_();\n    this.image_ = null;\n    super.disposeInternal();\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n","/**\n * @module ol/structs/LRUCache\n */\n\nimport Disposable from '../Disposable.js';\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Entry|null} newer Newer.\n * @property {Entry|null} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},\n   * the entry will be disposed.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      const entry = this.pop();\n      if (entry instanceof Disposable) {\n        entry.dispose();\n      }\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T|undefined} Value.\n   */\n  peek(key) {\n    return this.entries_[key]?.value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(\n      !(key in this.entries_),\n      'Tried to set a value for a key that is used already',\n    );\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n","/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  }\n  return [z, x, y];\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n    .split(',')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @return {number} Hash.\n */\nexport function hashZXY(z, x, y) {\n  return (x << z) + y;\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  }\n  return tileRange.containsXY(x, y);\n}\n","/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n  }\n\n  /**\n   * @return {number|undefined} The suggested cache size\n   * @protected\n   */\n  getCacheSize() {\n    return this.cacheSize_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   * @override\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n","/**\n * @module ol/DataTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\n */\n\n/**\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\n */\n\n/**\n * Data that can be used with a DataTile.\n * @typedef {ArrayLike|ImageLike} Data\n */\n\n/**\n * @param {Data} data Tile data.\n * @return {ImageLike|null} The image-like data.\n */\nexport function asImageLike(data) {\n  return data instanceof Image ||\n    data instanceof HTMLCanvasElement ||\n    data instanceof HTMLVideoElement ||\n    data instanceof ImageBitmap\n    ? data\n    : null;\n}\n\n/**\n * @param {Data} data Tile data.\n * @return {ArrayLike|null} The array-like data.\n */\nexport function asArrayLike(data) {\n  return data instanceof Uint8Array ||\n    data instanceof Uint8ClampedArray ||\n    data instanceof Float32Array ||\n    data instanceof DataView\n    ? data\n    : null;\n}\n\n/**\n * This is set as the cancellation reason when a tile is disposed.\n */\nexport const disposedError = new Error('disposed');\n\n/**\n * @type {CanvasRenderingContext2D|null}\n */\nlet sharedContext = null;\n\n/**\n * @param {ImageLike} image The image.\n * @return {Uint8ClampedArray} The data.\n */\nexport function toArray(image) {\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(\n      image.width,\n      image.height,\n      undefined,\n      {willReadFrequently: true},\n    );\n  }\n  const canvas = sharedContext.canvas;\n  const width = image.width;\n  if (canvas.width !== width) {\n    canvas.width = width;\n  }\n  const height = image.height;\n  if (canvas.height !== height) {\n    canvas.height = height;\n  }\n  sharedContext.clearRect(0, 0, width, height);\n  sharedContext.drawImage(image, 0, 0);\n  return sharedContext.getImageData(0, 0, width, height).data;\n}\n\n/**\n * @type {import('./size.js').Size}\n */\nconst defaultSize = [256, 256];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\n * the promise should not resolve until the image is loaded.\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\n * @property {AbortController} [controller] An abort controller.\n * @api\n */\n\nclass DataTile extends Tile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    const state = TileState.IDLE;\n\n    super(options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @type {function(): Promise<Data>}\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @type {Data}\n     * @private\n     */\n    this.data_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {import('./size.js').Size|null}\n     * @private\n     */\n    this.size_ = options.size || null;\n\n    /**\n     * @type {AbortController|null}\n     * @private\n     */\n    this.controller_ = options.controller || null;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('./size.js').Size} Tile size.\n   */\n  getSize() {\n    if (this.size_) {\n      return this.size_;\n    }\n    const imageData = asImageLike(this.data_);\n    if (imageData) {\n      return [imageData.width, imageData.height];\n    }\n    return defaultSize;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {Data} Tile data.\n   * @api\n   */\n  getData() {\n    return this.data_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @api\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Load the tile data.\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    const self = this;\n    this.loader_()\n      .then(function (data) {\n        self.data_ = data;\n        self.state = TileState.LOADED;\n        self.changed();\n      })\n      .catch(function (error) {\n        self.error_ = error;\n        self.state = TileState.ERROR;\n        self.changed();\n      });\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    if (this.controller_) {\n      this.controller_.abort(disposedError);\n      this.controller_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default DataTile;\n","/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n","/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution,\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overall reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256),\n              ),\n            ),\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision,\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0],\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0],\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1,\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n","/**\n * @module ol/reproj\n */\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\nimport {getPointResolution, transform} from './proj.js';\nimport {solveLinearSystem} from './math.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n    releaseCanvas(ctx);\n    canvasPool.push(ctx.canvas);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution,\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter,\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution,\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution,\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution,\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {import(\"./extent.js\").Extent} [clipExtent] Clip extent.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.\n * @param {boolean} [clipExtent] Clip stitchContext to sourceExtent.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  renderEdges,\n  interpolate,\n  drawSingle,\n  clipExtent,\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height),\n    canvasPool,\n  );\n\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  let stitchContext;\n  const stitchScale = pixelRatio / sourceResolution;\n  // Round up Float32 scale values to prevent interpolation in Firefox.\n  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;\n\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchContext = createCanvasContext2D(\n      Math.round(getWidth(sourceDataExtent) * stitchScale),\n      Math.round(getHeight(sourceDataExtent) * stitchScale),\n      canvasPool,\n    );\n\n    if (!interpolate) {\n      stitchContext.imageSmoothingEnabled = false;\n    }\n    if (sourceExtent && clipExtent) {\n      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;\n      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;\n      const width = getWidth(sourceExtent) * stitchScale;\n      const height = getHeight(sourceExtent) * stitchScale;\n      stitchContext.rect(xPos, yPos, width, height);\n      stitchContext.clip();\n    }\n\n    sources.forEach(function (src, i, arr) {\n      // This test should never fail -- but it does. Need to find a fix the upstream condition\n      if (src.image.width > 0 && src.image.height > 0) {\n        if (src.clipExtent) {\n          stitchContext.save();\n          const xPos = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;\n          const yPos = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;\n          const width = getWidth(src.clipExtent) * stitchScale;\n          const height = getHeight(src.clipExtent) * stitchScale;\n          stitchContext.rect(\n            interpolate ? xPos : Math.round(xPos),\n            interpolate ? yPos : Math.round(yPos),\n            interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\n            interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\n          );\n          stitchContext.clip();\n        }\n\n        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;\n        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;\n        const srcWidth = getWidth(src.extent) * stitchScale;\n        const srcHeight = getHeight(src.extent) * stitchScale;\n        stitchContext.drawImage(\n          src.image,\n          gutter,\n          gutter,\n          src.image.width - 2 * gutter,\n          src.image.height - 2 * gutter,\n          interpolate ? xPos : Math.round(xPos),\n          interpolate ? yPos : Math.round(yPos),\n          interpolate\n            ? srcWidth\n            : Math.round(xPos + srcWidth) - Math.round(xPos),\n          interpolate\n            ? srcHeight\n            : Math.round(yPos + srcHeight) - Math.round(yPos),\n        );\n\n        if (src.clipExtent) {\n          stitchContext.restore();\n        }\n      }\n    });\n  }\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution,\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution,\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution,\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1)),\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1)),\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0,\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY,\n    );\n\n    let image;\n    if (stitchContext) {\n      image = stitchContext.canvas;\n      context.scale(inverseScale, -inverseScale);\n    } else {\n      const source = sources[0];\n      const extent = source.extent;\n      image = source.image;\n      context.scale(\n        getWidth(extent) / image.width,\n        -getHeight(extent) / image.height,\n      );\n    }\n\n    context.drawImage(image, 0, 0);\n    context.restore();\n  });\n\n  if (stitchContext) {\n    releaseCanvas(stitchContext);\n    canvasPool.push(stitchContext.canvas);\n  }\n\n  if (renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n","/**\n * @module ol/reproj/DataTile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D, releaseCanvas} from '../dom.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {DataTile} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8ClampedArray(4)),\n      interpolate: options.interpolate,\n      transition: options.transition,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceTileGridExtent\n        ? getIntersection(sourceProjExtent, sourceTileGridExtent)\n        : sourceProjExtent\n      : sourceTileGridExtent;\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      options.errorThreshold !== undefined\n        ? options.errorThreshold\n        : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n        const getTile = options.getTileFunction;\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   * @override\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   * @override\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @override\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    let imageLike = false;\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        imageLike = true;\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8ClampedArray;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(\n        bytesPerRow / bytesPerElement / pixelSize[0],\n      );\n      const packedLength = pixelCount * bandCount;\n      let packedData = tileDataR;\n      if (tileDataR.length !== packedLength) {\n        packedData = new DataType(packedLength);\n        let dataIndex = 0;\n        let rowOffset = 0;\n        const colCount = pixelSize[0] * bandCount;\n        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n          for (let colIndex = 0; colIndex < colCount; ++colIndex) {\n            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];\n          }\n          rowOffset += bytesPerRow / bytesPerElement;\n        }\n      }\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n      extent[0] += source.offset;\n      extent[2] += source.offset;\n      const clipExtent = this.clipExtent_?.slice();\n      if (clipExtent) {\n        clipExtent[0] += source.offset;\n        clipExtent[2] += source.offset;\n      }\n      dataSources.push({\n        extent: extent,\n        clipExtent: clipExtent,\n        data: new Uint8ClampedArray(packedData.buffer),\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n      this.changed();\n      return;\n    }\n\n    const z = this.wrappedTileCoord_[0];\n    const size = this.targetTileGrid_.getTileSize(z);\n    const targetWidth = typeof size === 'number' ? size : size[0];\n    const targetHeight = typeof size === 'number' ? size : size[1];\n    const targetResolution = this.targetTileGrid_.getResolution(z);\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n\n    let dataR, dataU;\n\n    const bytesPerPixel = dataSources[0].bytesPerPixel;\n\n    const reprojs = Math.ceil(bytesPerPixel / 3);\n    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n      const sources = [];\n      for (let i = 0, len = dataSources.length; i < len; ++i) {\n        const dataSource = dataSources[i];\n        const buffer = dataSource.data;\n        const pixelSize = dataSource.pixelSize;\n        const width = pixelSize[0];\n        const height = pixelSize[1];\n        const context = createCanvasContext2D(width, height, canvasPool);\n        const imageData = context.createImageData(width, height);\n        const data = imageData.data;\n        let offset = reproj * 3;\n        for (let j = 0, len = data.length; j < len; j += 4) {\n          data[j] = buffer[offset];\n          data[j + 1] = buffer[offset + 1];\n          data[j + 2] = buffer[offset + 2];\n          data[j + 3] = 255;\n          offset += bytesPerPixel;\n        }\n        context.putImageData(imageData, 0, 0);\n        sources.push({\n          extent: dataSource.extent,\n          clipExtent: dataSource.clipExtent,\n          image: context.canvas,\n        });\n      }\n\n      const canvas = renderReprojected(\n        targetWidth,\n        targetHeight,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        false,\n        false,\n        false,\n      );\n\n      for (let i = 0, len = sources.length; i < len; ++i) {\n        const canvas = sources[i].image;\n        const context = canvas.getContext('2d');\n        releaseCanvas(context);\n        canvasPool.push(context.canvas);\n      }\n\n      const context = canvas.getContext('2d');\n      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n\n      releaseCanvas(context);\n      canvasPool.push(canvas);\n\n      if (!dataR) {\n        dataU = new Uint8ClampedArray(\n          bytesPerPixel * imageData.width * imageData.height,\n        );\n        dataR = new dataSources[0].dataType(dataU.buffer);\n      }\n\n      const data = imageData.data;\n      let offset = reproj * 3;\n      for (let i = 0, len = data.length; i < len; i += 4) {\n        if (data[i + 3] === 255) {\n          dataU[offset] = data[i];\n          dataU[offset + 1] = data[i + 1];\n          dataU[offset + 2] = data[i + 2];\n        } else {\n          dataU[offset] = 0;\n          dataU[offset + 1] = 0;\n          dataU[offset + 2] = 0;\n        }\n        offset += bytesPerPixel;\n      }\n    }\n\n    if (imageLike) {\n      const context = createCanvasContext2D(targetWidth, targetHeight);\n      const imageData = new ImageData(dataR, targetWidth);\n      context.putImageData(imageData, 0, 0);\n      this.reprojData_ = context.canvas;\n    } else {\n      this.reprojData_ = dataR;\n    }\n    this.reprojSize_ = [\n      Math.round(targetWidth * this.pixelRatio_),\n      Math.round(targetHeight * this.pixelRatio_),\n    ];\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    let leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(({tile}) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n\n      const sourceListenKey = listen(tile, EventType.CHANGE, () => {\n        const state = tile.getState();\n        if (\n          state == TileState.LOADED ||\n          state == TileState.ERROR ||\n          state == TileState.EMPTY\n        ) {\n          unlistenByKey(sourceListenKey);\n          leftToLoad--;\n          if (leftToLoad === 0) {\n            this.unlistenSources_();\n            this.reproject_();\n          }\n        }\n      });\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function ({tile}) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojDataTile;\n","/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {releaseCanvas} from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options,\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceProj.getExtent()\n      : undefined;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate,\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({tile}) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(tile, EventType.CHANGE, (e) => {\n            const state = tile.getState();\n            if (\n              state == TileState.LOADED ||\n              state == TileState.ERROR ||\n              state == TileState.EMPTY\n            ) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          });\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   * @override\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n","/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(sourceKey, z, x, y) {\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection_ = undefined;\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection_) {\n      this.renderedProjection_ = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection_) {\n      this.tileCache_.clear();\n      this.renderedProjection_ = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedRevision_) {\n      this.renderedRevision_ = sourceRevision;\n    } else if (this.renderedRevision_ !== sourceRevision) {\n      this.renderedRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.get(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.get(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  * maybe skip transition when not fully opaque\n     *  * decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tileState === TileState.EMPTY\n      ) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      this.renderComplete = false;\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = (map, frameState) => {\n      const tileSourceKey = getUid(tileSource);\n      const wantedTiles = frameState.wantedTiles[tileSourceKey];\n      const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n      this.updateCacheSize(tilesCount);\n      this.tileCache_.expireCache();\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/layer/Tile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} [TileSourceType=import(\"../source/Tile.js\").default]\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\n * @api\n */\nclass TileLayer extends BaseTileLayer {\n  /**\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasTileLayerRenderer(this, {\n      cacheSize: this.getCacheSize(),\n    });\n  }\n}\n\nexport default TileLayer;\n","/**\n * @module ol/source/TileEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a tile starts loading.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n   * @api\n   */\n  TILELOADSTART: 'tileloadstart',\n\n  /**\n   * Triggered when a tile finishes loading, either when its data is loaded,\n   * or when loading was aborted because the tile is no longer needed.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n   * @api\n   */\n  TILELOADEND: 'tileloadend',\n\n  /**\n   * Triggered if tile loading results in an error. Note that this is not the\n   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}\n   * for details.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n   * @api\n   */\n  TILELOADERROR: 'tileloaderror',\n};\n\n/**\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\n */\n","/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, {\n  createOrUpdate as createOrUpdateTileRange,\n} from '../TileRange.js';\nimport {DEFAULT_TILE_SIZE} from './common.js';\nimport {assert} from '../asserts.js';\nimport {ceil, clamp, floor} from '../math.js';\nimport {createOrUpdate, getTopLeft} from '../extent.js';\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\nimport {intersectsLinearRing} from '../geom/flat/intersectsextent.js';\nimport {isSorted, linearFindNearest} from '../array.js';\nimport {toSize} from '../size.js';\n\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nconst tmpTileCoord = [0, 0, 0];\n\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nconst DECIMALS = 5;\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nclass TileGrid {\n  /**\n   * @param {Options} options Tile grid options.\n   */\n  constructor(options) {\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n\n    /**\n     * @private\n     * @type {!Array<number>}\n     */\n    this.resolutions_ = options.resolutions;\n    assert(\n      isSorted(\n        this.resolutions_,\n        /**\n         * @param {number} a First resolution\n         * @param {number} b Second resolution\n         * @return {number} Comparison result\n         */\n        (a, b) => b - a,\n        true,\n      ),\n      '`resolutions` must be sorted in descending order',\n    );\n\n    // check if we've got a consistent zoom factor and origin\n    let zoomFactor;\n    if (!options.origins) {\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n        if (!zoomFactor) {\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n        } else {\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n            zoomFactor = undefined;\n            break;\n          }\n        }\n      }\n    }\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.zoomFactor_ = zoomFactor;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxZoom = this.resolutions_.length - 1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.origin_ = options.origin !== undefined ? options.origin : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\n     */\n    this.origins_ = null;\n    if (options.origins !== undefined) {\n      this.origins_ = options.origins;\n      assert(\n        this.origins_.length == this.resolutions_.length,\n        'Number of `origins` and `resolutions` must be equal',\n      );\n    }\n\n    const extent = options.extent;\n\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\n      this.origin_ = getTopLeft(extent);\n    }\n\n    assert(\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n      'Either `origin` or `origins` must be configured, never both',\n    );\n\n    /**\n     * @private\n     * @type {Array<number|import(\"../size.js\").Size>}\n     */\n    this.tileSizes_ = null;\n    if (options.tileSizes !== undefined) {\n      this.tileSizes_ = options.tileSizes;\n      assert(\n        this.tileSizes_.length == this.resolutions_.length,\n        'Number of `tileSizes` and `resolutions` must be equal',\n      );\n    }\n\n    /**\n     * @private\n     * @type {number|import(\"../size.js\").Size}\n     */\n    this.tileSize_ =\n      options.tileSize !== undefined\n        ? options.tileSize\n        : !this.tileSizes_\n          ? DEFAULT_TILE_SIZE\n          : null;\n    assert(\n      (!this.tileSize_ && this.tileSizes_) ||\n        (this.tileSize_ && !this.tileSizes_),\n      'Either `tileSize` or `tileSizes` must be configured, never both',\n    );\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent !== undefined ? extent : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../TileRange.js\").default>}\n     */\n    this.fullTileRanges_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize_ = [0, 0];\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.tmpExtent_ = [0, 0, 0, 0];\n\n    if (options.sizes !== undefined) {\n      this.fullTileRanges_ = options.sizes.map((size, z) => {\n        const tileRange = new TileRange(\n          Math.min(0, size[0]),\n          Math.max(size[0] - 1, -1),\n          Math.min(0, size[1]),\n          Math.max(size[1] - 1, -1),\n        );\n        if (extent) {\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n        }\n        return tileRange;\n      });\n    } else if (extent) {\n      this.calculateTileRanges_(extent);\n    }\n  }\n\n  /**\n   * Call a function with each tile coordinate for a given extent and zoom level.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} zoom Integer zoom level.\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n   * @api\n   */\n  forEachTileCoord(extent, zoom, callback) {\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n        callback([zoom, i, j]);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {boolean} Callback succeeded.\n   */\n  forEachTileCoordParentTileRange(\n    tileCoord,\n    callback,\n    tempTileRange,\n    tempExtent,\n  ) {\n    let tileRange, x, y;\n    let tileCoordExtent = null;\n    let z = tileCoord[0] - 1;\n    if (this.zoomFactor_ === 2) {\n      x = tileCoord[1];\n      y = tileCoord[2];\n    } else {\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);\n    }\n    while (z >= this.minZoom) {\n      if (x !== undefined && y !== undefined) {\n        x = Math.floor(x / 2);\n        y = Math.floor(y / 2);\n        tileRange = createOrUpdateTileRange(x, x, y, y, tempTileRange);\n      } else {\n        tileRange = this.getTileRangeForExtentAndZ(\n          tileCoordExtent,\n          z,\n          tempTileRange,\n        );\n      }\n      if (callback(z, tileRange)) {\n        return true;\n      }\n      --z;\n    }\n    return false;\n  }\n\n  /**\n   * Get the extent for this tile grid, if it was configured.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the maximum zoom level for the grid.\n   * @return {number} Max zoom.\n   * @api\n   */\n  getMaxZoom() {\n    return this.maxZoom;\n  }\n\n  /**\n   * Get the minimum zoom level for the grid.\n   * @return {number} Min zoom.\n   * @api\n   */\n  getMinZoom() {\n    return this.minZoom;\n  }\n\n  /**\n   * Get the origin for the grid at the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\n   * @api\n   */\n  getOrigin(z) {\n    if (this.origin_) {\n      return this.origin_;\n    }\n    return this.origins_[z];\n  }\n\n  /**\n   * Get the resolution for the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {number} Resolution.\n   * @api\n   */\n  getResolution(z) {\n    return this.resolutions_[z];\n  }\n\n  /**\n   * Get the list of resolutions for the tile grid.\n   * @return {Array<number>} Resolutions.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\n   */\n  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {\n    if (tileCoord[0] < this.maxZoom) {\n      if (this.zoomFactor_ === 2) {\n        const minX = tileCoord[1] * 2;\n        const minY = tileCoord[2] * 2;\n        return createOrUpdateTileRange(\n          minX,\n          minX + 1,\n          minY,\n          minY + 1,\n          tempTileRange,\n        );\n      }\n      const tileCoordExtent = this.getTileCoordExtent(\n        tileCoord,\n        tempExtent || this.tmpExtent_,\n      );\n      return this.getTileRangeForExtentAndZ(\n        tileCoordExtent,\n        tileCoord[0] + 1,\n        tempTileRange,\n      );\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\n   */\n  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {\n    if (z > this.maxZoom || z < this.minZoom) {\n      return null;\n    }\n\n    const tileCoordZ = tileCoord[0];\n    const tileCoordX = tileCoord[1];\n    const tileCoordY = tileCoord[2];\n\n    if (z === tileCoordZ) {\n      return createOrUpdateTileRange(\n        tileCoordX,\n        tileCoordY,\n        tileCoordX,\n        tileCoordY,\n        tempTileRange,\n      );\n    }\n\n    if (this.zoomFactor_) {\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n      const minX = Math.floor(tileCoordX * factor);\n      const minY = Math.floor(tileCoordY * factor);\n      if (z < tileCoordZ) {\n        return createOrUpdateTileRange(minX, minX, minY, minY, tempTileRange);\n      }\n\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n      return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\n    }\n\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);\n  }\n\n  /**\n   * Get a tile range for the given extent and integer zoom level.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary tile range object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  getTileRangeForExtentAndZ(extent, z, tempTileRange) {\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);\n    const minX = tmpTileCoord[1];\n    const minY = tmpTileCoord[2];\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);\n    const maxX = tmpTileCoord[1];\n    const maxY = tmpTileCoord[2];\n    return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n   */\n  getTileCoordCenter(tileCoord) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    return [\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n    ];\n  }\n\n  /**\n   * Get the extent of a tile coordinate.\n   *\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getTileCoordExtent(tileCoord, tempExtent) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n    const maxX = minX + tileSize[0] * resolution;\n    const maxY = minY + tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\n  }\n\n  /**\n   * Get the tile coordinate for the given map coordinate and resolution.  This\n   * method considers that coordinates that intersect tile boundaries should be\n   * assigned the higher tile coordinate.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\n    return this.getTileCoordForXYAndResolution_(\n      coordinate[0],\n      coordinate[1],\n      resolution,\n      false,\n      opt_tileCoord,\n    );\n  }\n\n  /**\n   * Note that this method should not be called for resolutions that correspond\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} resolution Resolution (for a non-integer zoom level).\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndResolution_(\n    x,\n    y,\n    resolution,\n    reverseIntersectionPolicy,\n    opt_tileCoord,\n  ) {\n    const z = this.getZForResolution(resolution);\n    const scale = resolution / this.getResolution(z);\n    const origin = this.getOrigin(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\n    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = floor(tileCoordX, DECIMALS);\n      tileCoordY = floor(tileCoordY, DECIMALS);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n   * they should have separate implementations.  This method is for integer zoom\n   * levels.  The other method should only be called for resolutions corresponding\n   * to non-integer zoom levels.\n   * @param {number} x Map x coordinate.\n   * @param {number} y Map y coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];\n    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = floor(tileCoordX, DECIMALS);\n      tileCoordY = floor(tileCoordY, DECIMALS);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Get a tile coordinate given a map coordinate and zoom level.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\n    return this.getTileCoordForXYAndZ_(\n      coordinate[0],\n      coordinate[1],\n      z,\n      false,\n      opt_tileCoord,\n    );\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {number} Tile resolution.\n   */\n  getTileCoordResolution(tileCoord) {\n    return this.resolutions_[tileCoord[0]];\n  }\n\n  /**\n   * Get the tile size for a zoom level. The type of the return value matches the\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n   * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\n   * @param {number} z Z.\n   * @return {number|import(\"../size.js\").Size} Tile size.\n   * @api\n   */\n  getTileSize(z) {\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    return this.tileSizes_[z];\n  }\n\n  /**\n   * @param {number} z Zoom level.\n   * @return {import(\"../TileRange.js\").default|null} Extent tile range for the specified zoom level.\n   */\n  getFullTileRange(z) {\n    if (!this.fullTileRanges_) {\n      return this.extent_\n        ? this.getTileRangeForExtentAndZ(this.extent_, z)\n        : null;\n    }\n    return this.fullTileRanges_[z];\n  }\n\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\n   *     If 0, the nearest resolution will be used.\n   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\n   *     nearest lower resolution (higher Z) will be used. Default is 0.\n   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\n   *\n   * For example to change tile Z at the midpoint of zoom levels\n   * ```js\n   * function(value, high, low) {\n   *   return value - low * Math.sqrt(high / low);\n   * }\n   * ```\n   * @return {number} Z.\n   * @api\n   */\n  getZForResolution(resolution, opt_direction) {\n    const z = linearFindNearest(\n      this.resolutions_,\n      resolution,\n      opt_direction || 0,\n    );\n    return clamp(z, this.minZoom, this.maxZoom);\n  }\n\n  /**\n   * The tile with the provided tile coordinate intersects the given viewport.\n   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.\n   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.\n   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.\n   */\n  tileCoordIntersectsViewport(tileCoord, viewport) {\n    return intersectsLinearRing(\n      viewport,\n      0,\n      viewport.length,\n      2,\n      this.getTileCoordExtent(tileCoord),\n    );\n  }\n\n  /**\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n   * @private\n   */\n  calculateTileRanges_(extent) {\n    const length = this.resolutions_.length;\n    const fullTileRanges = new Array(length);\n    for (let z = this.minZoom; z < length; ++z) {\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n    }\n    this.fullTileRanges_ = fullTileRanges;\n  }\n}\n\nexport default TileGrid;\n","/**\n * @module ol/tilegrid\n */\nimport TileGrid from './tilegrid/TileGrid.js';\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\nimport {\n  containsCoordinate,\n  createOrUpdate,\n  getCorner,\n  getHeight,\n  getWidth,\n} from './extent.js';\nimport {toSize} from './size.js';\n\nexport {TileGrid};\nexport {default as WMTS} from './tilegrid/WMTS.js';\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  let tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  const z = tileCoord[0];\n  const center = tileGrid.getTileCoordCenter(tileCoord);\n  const projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.ceil(\n      (projectionExtent[0] - center[0]) / worldWidth,\n    );\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  }\n  return tileCoord;\n}\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, maxZoom, tileSize, corner) {\n  corner = corner !== undefined ? corner : 'top-left';\n\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: tileSize,\n  });\n}\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(options) {\n  const xyzOptions = options || {};\n\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  const gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize,\n      xyzOptions.maxResolution,\n    ),\n  };\n  return new TileGrid(gridOptions);\n}\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\n  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;\n  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);\n\n  const height = getHeight(extent);\n  const width = getWidth(extent);\n\n  maxResolution =\n    maxResolution > 0\n      ? maxResolution\n      : Math.max(width / tileSize[0], height / tileSize[1]);\n\n  const length = maxZoom + 1;\n  const resolutions = new Array(length);\n  for (let z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, maxZoom, tileSize, corner) {\n  const extent = extentFromProjection(projection);\n  return createForExtent(extent, maxZoom, tileSize, corner);\n}\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  let extent = projection.getExtent();\n  if (!extent) {\n    const half =\n      (180 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n","/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport Source from './Source.js';\nimport {abstract, getUid} from '../util.js';\nimport {\n  getForProjection as getTileGridForProjection,\n  wrapX,\n} from '../tilegrid.js';\nimport {scale as scaleSize, toSize} from '../size.js';\nimport {withinExtentAndZ} from '../tilecoord.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n *\n * @template {import(\"../Tile.js\").default} [TileType=import(\"../Tile.js\").default]\n * @abstract\n * @api\n */\nclass TileSource extends Source {\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n      interpolate: options.interpolate,\n    });\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TileSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ =\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n\n    /**\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\n     * @protected\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n\n    const tileSize = [256, 256];\n    if (this.tileGrid) {\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\n    }\n\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize = [0, 0];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = options.key || getUid(this);\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    this.tileOptions = {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    };\n\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = options.zDirection ? options.zDirection : 0;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n  getKey() {\n    return this.key_;\n  }\n\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   * @override\n   */\n  getResolutions(projection) {\n    const tileGrid = projection\n      ? this.getTileGridForProjection(projection)\n      : this.tileGrid;\n    if (!tileGrid) {\n      return null;\n    }\n    return tileGrid.getResolutions();\n  }\n\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {TileType|null} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\n   * @api\n   */\n  getTileGrid() {\n    return this.tileGrid;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    }\n    return this.tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    }\n    return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n  }\n\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\n    projection = projection !== undefined ? projection : this.getProjection();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (this.getWrapX() && projection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  }\n\n  /**\n   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.\n   * @api\n   */\n  clear() {}\n\n  /**\n   * @override\n   */\n  refresh() {\n    this.clear();\n    super.refresh();\n  }\n}\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nexport class TileSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  constructor(type, tile) {\n    super(type);\n\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    this.tile = tile;\n  }\n}\n\nexport default TileSource;\n","/**\n * @module ol/uri\n */\n\nimport {hashZXY} from './tilecoord.js';\nimport {modulo} from './math.js';\n\n/**\n * Appends query parameters to a URI.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {!Object} params An object where keys are URI-encoded parameter keys,\n *     and the values are arbitrary types or arrays.\n * @return {string} The new URI.\n */\nexport function appendParams(uri, params) {\n  /** @type {Array<string>} */\n  const keyParams = [];\n  // Skip any null or undefined parameter values\n  Object.keys(params).forEach(function (k) {\n    if (params[k] !== null && params[k] !== undefined) {\n      keyParams.push(k + '=' + encodeURIComponent(params[k]));\n    }\n  });\n  const qs = keyParams.join('&');\n  // remove any trailing ? or &\n  uri = uri.replace(/[?&]$/, '');\n  // append ? or & depending on whether uri has existing parameters\n  uri += uri.includes('?') ? '&' : '?';\n  return uri + qs;\n}\n\nconst zRegEx = /\\{z\\}/g;\nconst xRegEx = /\\{x\\}/g;\nconst yRegEx = /\\{y\\}/g;\nconst dashYRegEx = /\\{-y\\}/g;\n\n/**\n * @param {string} template The URL template.  Should have `{x}`, `{y}`, and `{z}` placeholders.  If\n * the template has a `{-y}` placeholder, the `maxY` parameter must be supplied.\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @param {number} [maxY] The maximum y coordinate at the given z level.\n * @return {string} The URL.\n */\nexport function renderXYZTemplate(template, z, x, y, maxY) {\n  return template\n    .replace(zRegEx, z.toString())\n    .replace(xRegEx, x.toString())\n    .replace(yRegEx, y.toString())\n    .replace(dashYRegEx, function () {\n      if (maxY === undefined) {\n        throw new Error(\n          'If the URL template has a {-y} placeholder, the grid extent must be known',\n        );\n      }\n      return (maxY - y).toString();\n    });\n}\n\n/**\n * @param {Array<string>} urls List of URLs.\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @return {string} The chosen URL.\n */\nexport function pickUrl(urls, z, x, y) {\n  const hash = hashZXY(z, x, y);\n  const index = modulo(hash, urls.length);\n  return urls[index];\n}\n\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n  const urls = [];\n  let match = /\\{([a-z])-([a-z])\\}/.exec(url);\n  if (match) {\n    // char range\n    const startCharCode = match[1].charCodeAt(0);\n    const stopCharCode = match[2].charCodeAt(0);\n    let charCode;\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n    }\n    return urls;\n  }\n  match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n  if (match) {\n    // number range\n    const stop = parseInt(match[2], 10);\n    for (let i = parseInt(match[1], 10); i <= stop; i++) {\n      urls.push(url.replace(match[0], i.toString()));\n    }\n    return urls;\n  }\n  urls.push(url);\n  return urls;\n}\n","/**\n * @module ol/tileurlfunction\n */\nimport {modulo} from './math.js';\nimport {renderXYZTemplate} from './uri.js';\nimport {hash as tileCoordHash} from './tilecoord.js';\n\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default|null} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      }\n      let maxY;\n      const z = tileCoord[0];\n      if (tileGrid) {\n        // The `{-y}` placeholder only works for sources that have a tile grid at construction\n        const range = tileGrid.getFullTileRange(z);\n        if (range) {\n          maxY = range.getHeight() - 1;\n        }\n      }\n      return renderXYZTemplate(template, z, tileCoord[1], tileCoord[2], maxY);\n    }\n  );\n}\n\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n  const len = templates.length;\n  const tileUrlFunctions = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n  }\n  return createFromTileUrlFunctions(tileUrlFunctions);\n}\n\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n  if (tileUrlFunctions.length === 1) {\n    return tileUrlFunctions[0];\n  }\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      }\n      const h = tileCoordHash(tileCoord);\n      const index = modulo(h, tileUrlFunctions.length);\n      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n    }\n  );\n}\n\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n  return undefined;\n}\n\n/**\n * TODO: Update ol-mapbox-style to import this from the uri.js module.\n */\nexport {expandUrl} from './uri.js';\n","/**\n * @module ol/source/UrlTile\n */\nimport TileEventType from './TileEventType.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileState from '../TileState.js';\nimport {createFromTemplates} from '../tileurlfunction.js';\nimport {expandUrl} from '../uri.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction TileLoadFunction.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function\n * for the url option instead.\n * @property {string} [url] Url.\n * @property {Array<string>} [urls] Urls.\n * @property {boolean} [wrapX=true] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @deprecated Use the ol/source/ImageTile.js instead.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n */\nclass UrlTile extends TileSource {\n  /**\n   * @param {Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.generateTileUrlFunction_ =\n      this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction = options.tileLoadFunction;\n\n    if (options.tileUrlFunction) {\n      this.tileUrlFunction = options.tileUrlFunction;\n    }\n\n    /**\n     * @protected\n     * @type {!Array<string>|null}\n     */\n    this.urls = null;\n\n    if (options.urls) {\n      this.setUrls(options.urls);\n    } else if (options.url) {\n      this.setUrl(options.url);\n    }\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Return the tile load function of the source.\n   * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\n   * @api\n   */\n  getTileLoadFunction() {\n    return this.tileLoadFunction;\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Return the tile URL function of the source.\n   * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\n   * @api\n   */\n  getTileUrlFunction() {\n    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction\n      ? this.tileUrlFunction.bind(this)\n      : this.tileUrlFunction;\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Return the URLs used for this source.\n   * When a tileUrlFunction is used instead of url or urls,\n   * null will be returned.\n   * @return {!Array<string>|null} URLs.\n   * @api\n   */\n  getUrls() {\n    return this.urls;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleTileChange(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n            ? TileEventType.TILELOADEND\n            : undefined;\n    }\n    if (type != undefined) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Set the tile load function of the source.\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @api\n   */\n  setTileLoadFunction(tileLoadFunction) {\n    this.tileLoadFunction = tileLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Set the tile URL function of the source.\n   * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\n   * @param {string} [key] Optional new tile key for the source.\n   * @api\n   */\n  setTileUrlFunction(tileUrlFunction, key) {\n    this.tileUrlFunction = tileUrlFunction;\n    if (typeof key !== 'undefined') {\n      this.setKey(key);\n    } else {\n      this.changed();\n    }\n  }\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string} url URL.\n   * @api\n   */\n  setUrl(url) {\n    const urls = expandUrl(url);\n    this.urls = urls;\n    this.setUrls(urls);\n  }\n\n  /**\n   * Deprecated.  Use an ImageTile source instead.\n   * Set the URLs to use for requests.\n   * @param {Array<string>} urls URLs.\n   * @api\n   */\n  setUrls(urls) {\n    this.urls = urls;\n    const key = urls.join('\\n');\n    if (this.generateTileUrlFunction_) {\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n    } else {\n      this.setKey(key);\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {string|undefined} Tile URL.\n   */\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\n    return undefined;\n  }\n}\n\nexport default UrlTile;\n","/**\n * @module ol/source/TileImage\n */\nimport EventType from '../events/EventType.js';\nimport ImageTile from '../ImageTile.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport {getForProjection as getTileGridForProjection} from '../tilegrid.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\n * service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function\n * for the url option instead.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\n * request out-of-bounds tiles from the server. When set to `false`, only one\n * world will be rendered. When set to `true`, tiles will be requested for one\n * world only, but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [key] Optional tile key for proper cache fetching\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @deprecated Use the ol/source/ImageTile.js instead.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass TileImage extends UrlTile {\n  /**\n   * @param {!Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultTileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate:\n        options.interpolate !== undefined ? options.interpolate : true,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @protected\n     * @type {?string}\n     */\n    this.crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @protected\n     * @type {typeof ImageTile}\n     */\n    this.tileClass =\n      options.tileClass !== undefined ? options.tileClass : ImageTile;\n\n    /**\n     * @protected\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection = {};\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderReprojectionEdges_ = false;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   * @override\n   */\n  getGutterForProjection(projection) {\n    if (\n      this.getProjection() &&\n      projection &&\n      !equivalent(this.getProjection(), projection)\n    ) {\n      return 0;\n    }\n    return this.getGutter();\n  }\n\n  /**\n   * @return {number} Gutter.\n   */\n  getGutter() {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @override\n   */\n  getKey() {\n    let key = super.getKey();\n    if (!this.getInterpolate()) {\n      key += ':disable-interpolation';\n    }\n    return key;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    }\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileGridForProjection)) {\n      this.tileGridForProjection[projKey] =\n        getTileGridForProjection(projection);\n    }\n    return this.tileGridForProjection[projKey];\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {string} key The key set on the tile.\n   * @return {!ImageTile} Tile.\n   * @private\n   */\n  createTile_(z, x, y, pixelRatio, projection, key) {\n    const tileCoord = [z, x, y];\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const tileUrl = urlTileCoord\n      ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)\n      : undefined;\n    const tile = new this.tileClass(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.crossOrigin,\n      this.tileLoadFunction,\n      this.tileOptions,\n    );\n    tile.key = key;\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!(ImageTile|ReprojTile)} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      !sourceProjection ||\n      !projection ||\n      equivalent(sourceProjection, projection)\n    ) {\n      return this.getTileInternal(\n        z,\n        x,\n        y,\n        pixelRatio,\n        sourceProjection || projection,\n      );\n    }\n    const tileCoord = [z, x, y];\n    const key = this.getKey();\n    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n    const targetTileGrid = this.getTileGridForProjection(projection);\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const tile = new ReprojTile(\n      sourceProjection,\n      sourceTileGrid,\n      projection,\n      targetTileGrid,\n      tileCoord,\n      wrappedTileCoord,\n      this.getTilePixelRatio(pixelRatio),\n      this.getGutter(),\n      (z, x, y, pixelRatio) =>\n        this.getTileInternal(z, x, y, pixelRatio, sourceProjection),\n      this.reprojectionErrorThreshold_,\n      this.renderReprojectionEdges_,\n      this.tileOptions,\n    );\n    tile.key = key;\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {!import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!ImageTile} Tile.\n   * @protected\n   */\n  getTileInternal(z, x, y, pixelRatio, projection) {\n    const key = this.getKey();\n    return this.createTile_(z, x, y, pixelRatio, projection, key);\n  }\n\n  /**\n   * Sets whether to render reprojection edges or not (usually for debugging).\n   * @param {boolean} render Render the edges.\n   * @api\n   */\n  setRenderReprojectionEdges(render) {\n    if (this.renderReprojectionEdges_ == render) {\n      return;\n    }\n    this.renderReprojectionEdges_ = render;\n    this.changed();\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection)) {\n        this.tileGridForProjection[projKey] = tilegrid;\n      }\n    }\n  }\n}\n\n/**\n * @param {ImageTile} imageTile Image tile.\n * @param {string} src Source.\n */\nfunction defaultTileLoadFunction(imageTile, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src =\n    src;\n}\n\nexport default TileImage;\n","/**\n * @module ol/source/XYZ\n */\n\nimport TileImage from './TileImage.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Deprecated.  Use an ImageTile source with a loader\n * instead.  Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\n * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n * Not used if `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported images should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function\n * for the url option instead.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,\n * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,\n * may be used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] Deprecated.  Use an ImageTile source and provide an array of URLs for the\n * url option instead.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data with URLs in a set XYZ format that are\n * defined in a URL template. By default, this follows the widely-used\n * Google grid where `x` 0 and `y` 0 are in the top left. Grids like\n * TMS where `x` 0 and `y` 0 are in the bottom left can be used by\n * using the `{-y}` placeholder in the URL template, so long as the\n * source does not have a custom tile grid. In this case\n * a `tileUrlFunction` can be used, such as:\n * ```js\n *  tileUrlFunction: function(coordinate) {\n *    return 'http://mapserver.com/' + coordinate[0] + '/' +\n *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';\n *  }\n * ```\n * @api\n */\nclass XYZ extends TileImage {\n  /**\n   * @param {Options} [options] XYZ options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    const projection =\n      options.projection !== undefined ? options.projection : 'EPSG:3857';\n\n    const tileGrid =\n      options.tileGrid !== undefined\n        ? options.tileGrid\n        : createXYZ({\n            extent: extentFromProjection(projection),\n            maxResolution: options.maxResolution,\n            maxZoom: options.maxZoom,\n            minZoom: options.minZoom,\n            tileSize: options.tileSize,\n          });\n\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      projection: projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n  }\n\n  /**\n   * @return {number} Gutter.\n   * @override\n   */\n  getGutter() {\n    return this.gutter_;\n  }\n}\n\nexport default XYZ;\n","/**\n * @module ol/source/OSM\n */\n\nimport XYZ from './XYZ.js';\n\n/**\n * The attribution containing a link to the OpenStreetMap Copyright and License\n * page.\n * @const\n * @type {string}\n * @api\n */\nexport const ATTRIBUTION =\n  '&#169; ' +\n  '<a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">OpenStreetMap</a> ' +\n  'contributors.';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {number} [maxZoom=19] Max zoom.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [url='https://tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.\n * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for the OpenStreetMap tile server.\n * @api\n */\nclass OSM extends XYZ {\n  /**\n   * @param {Options} [options] Open Street Map options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    let attributions;\n    if (options.attributions !== undefined) {\n      attributions = options.attributions;\n    } else {\n      attributions = [ATTRIBUTION];\n    }\n\n    const crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\n\n    const url =\n      options.url !== undefined\n        ? options.url\n        : 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';\n\n    super({\n      attributions: attributions,\n      attributionsCollapsible: false,\n      cacheSize: options.cacheSize,\n      crossOrigin: crossOrigin,\n      interpolate: options.interpolate,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileLoadFunction: options.tileLoadFunction,\n      transition: options.transition,\n      url: url,\n      wrapX: options.wrapX,\n      zDirection: options.zDirection,\n    });\n  }\n}\n\nexport default OSM;\n"],"names":["Tile","EventTarget","tileCoord","state","options","EventType","TileState","abstract","id","time","start","delta","easeIn","Tile$1","ImageTile","src","crossOrigin","tileLoadFunction","element","getBlankImage","image","listenImage","ctx","createCanvasContext2D","ImageTile$1","LRUCache","highWaterMark","keep","entry","Disposable","key","f","assert","keys","i","values","_a","value","size","LRUCache$1","createOrUpdate","z","x","y","getKeyZXY","hash","hashZXY","withinExtentAndZ","tileGrid","tileRange","TileRange","minX","maxX","minY","maxY","TileRange$1","TileProperty","BaseTileLayer","Layer","baseOptions","cacheSize","preload","useInterimTilesOnError","pixel","BaseTileLayer$1","asImageLike","data","asArrayLike","disposedError","sharedContext","toArray","canvas","width","height","defaultSize","DataTile","imageData","self","error","DataTile$1","ERROR_THRESHOLD","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","destinationResolution","transformInvCache","transformInv","getTransform","c","getWidth","destinationTopLeft","getTopLeft","destinationTopRight","getTopRight","destinationBottomRight","getBottomRight","destinationBottomLeft","getBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","getArea","leftBound","triangle","arr","newTriangle","a","b","aSrc","bSrc","cSrc","d","dSrc","sourceQuadExtent","boundingExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","targetQuadExtent","intersects","isNotFinite","center","centerSrc","dx","modulo","dy","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","extent","createEmpty","extendCoordinate","Triangulation$1","brokenDiagonalRendering_","canvasPool","drawTestTriangle","u1","v1","u2","v2","verifyBrokenDiagonalRendering","offset","isBrokenDiagonalRendering","releaseCanvas","calculateSourceResolution","targetCenter","targetResolution","sourceCenter","transform","sourceResolution","getPointResolution","targetMetersPerUnit","sourceMetersPerUnit","sourceExtent","containsCoordinate","compensationFactor","calculateSourceExtentResolution","getCenter","forEachCorner","corner","render","pixelRatio","triangulation","sources","gutter","renderEdges","interpolate","drawSingle","clipExtent","context","pixelRound","sourceDataExtent","extend","stitchContext","stitchScale","inverseScale","getHeight","xPos","yPos","srcWidth","srcHeight","targetTopLeft","source","target","x0","y0","x1","y1","x2","y2","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","solveLinearSystem","steps","ud","vd","step","ReprojDataTile","sourceProjExtent","sourceTileGridExtent","getIntersection","maxTargetExtent","limitedTargetExtent","errorThresholdInPixels","clamp","worldWidth","worldsAway","wrapAndSliceX","sourceRange","getTile","srcX","srcY","tile","dataSources","imageLike","tileData","arrayData","pixelSize","isFloat","pixelCount","DataType","tileDataR","bytesPerElement","bytesPerPixel","bytesPerRow","bandCount","packedLength","packedData","dataIndex","rowOffset","colCount","rowIndex","colIndex","targetWidth","targetHeight","dataR","dataU","reprojs","reproj","len","dataSource","buffer","j","renderReprojected","leftToLoad","sourceListenKey","listen","unlistenByKey","ReprojDataTile$1","ReprojTile","sourceTileGrid","targetTileGrid","wrappedTileCoord","getTileFunction","e","ReprojTile$1","getCacheKey","sourceKey","addTileToLookup","tilesByZ","set","existing","removeTileFromLookup","getRenderExtent","frameState","layerState","fromUserExtent","gridExtent","CanvasTileLayerRenderer","CanvasLayerRenderer","tileLayer","createTileCoord","tileCache","tileSource","cacheKey","layer","coordinate","applyTransform","layerExtent","viewState","tilePixelRatio","tileOrigin","tileSize","toSize","tileResolution","col","row","sourceRevision","initialZ","tileSourceKey","getUid","wantedTiles","map","minZ","tileQueueKey","staleKeys","altZ","covered","loaded","projection","viewResolution","viewCenter","frameExtent","canvasExtent","targetZ","nextExtent","renderExtent","uid","tileState","minZoom","parentZ","canvasScale","composeTransform","zs","ascending","currentClip","clips","clipZs","currentZ","currentTilePixelSize","currentScale","originTileCoord","originTileExtent","origin","tileGutter","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","equals","postRenderFunction","tilesCount","tileCount","alpha","alphaChanged","usedTiles","CanvasTileLayerRenderer$1","TileLayer","TileLayer$1","TileEventType","tmpTileCoord","DECIMALS","TileGrid","isSorted","zoomFactor","DEFAULT_TILE_SIZE","restrictedTileRange","zoom","callback","jj","tempTileRange","tempExtent","tileCoordExtent","createOrUpdateTileRange","tileCoordZ","tileCoordX","tileCoordY","factor","resolution","opt_tileCoord","reverseIntersectionPolicy","scale","ceil","floor","createOrUpdateTileCoord","opt_direction","linearFindNearest","viewport","intersectsLinearRing","length","fullTileRanges","TileGrid$1","getForProjection","createForProjection","wrapX","projectionExtent","extentFromProjection","createForExtent","maxZoom","resolutions","resolutionsFromExtent","getCorner","createXYZ","xyzOptions","getProjection","gridOptions","maxResolution","DEFAULT_MAX_ZOOM","half","METERS_PER_UNIT","TileSource","Source","getTileGridForProjection","scaleSize","TileSourceEvent","Event","type","TileSource$1","zRegEx","xRegEx","yRegEx","dashYRegEx","renderXYZTemplate","template","expandUrl","url","urls","match","startCharCode","stopCharCode","charCode","stop","createFromTemplate","range","createFromTemplates","templates","tileUrlFunctions","createFromTileUrlFunctions","tileCoordHash","index","UrlTile","event","tileUrlFunction","UrlTile$1","TileImage","defaultTileLoadFunction","equivalent","thisProj","projKey","urlTileCoord","tileUrl","sourceProjection","tilegrid","proj","imageTile","TileImage$1","XYZ","XYZ$1","ATTRIBUTION","OSM","attributions","OSM$1"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]}